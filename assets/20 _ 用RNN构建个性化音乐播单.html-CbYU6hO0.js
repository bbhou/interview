import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,a as e,b as t,d as a,o as r}from"./app-d8EKP-K0.js";const n={};function s(c,p){return r(),o("div",null,p[0]||(p[0]=[e('<h1 id="_20-用rnn构建个性化音乐播单" tabindex="-1"><a class="header-anchor" href="#_20-用rnn构建个性化音乐播单"><span>20 _ 用RNN构建个性化音乐播单</span></a></h1><p><audio id="audio" title="20 | 用RNN构建个性化音乐播单" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/8a/10/8ab8d1628502c5b54cbc68bc9d171210.mp3"></audio></p><p>时间是一个客观存在的物理属性，很多数据都有时间属性，只不过大多时候都把它忽略掉了。前面讲到的绝大多数推荐算法，也都没有考虑“用户在产品上作出任何行为”都是有时间先后的。</p><p>正是认识到这一点，有一些矩阵分解算法考虑了时间属性，比如Time-SVD；但是，这种做法只是把时间作为一个独立特征加入到模型中，仍然没有给时间一个正确的名分。</p><h2 id="时间的重要性" tabindex="-1"><a class="header-anchor" href="#时间的重要性"><span>时间的重要性</span></a></h2><p>时间属性反应在序列的先后上，比如用户在视频网站上观看电视剧会先看第一集再看第二集，股市数据先有昨天的再有今天的，说“我订阅了《推荐系统36式》专栏”这句话时，词语也有先后，这种先后的关系就是时间序列。</p><p>具体到推荐系统领域，时间序列就是用户操作行为的先后。绝大数推荐算法都忽略操作的先后顺序，为什么要采取这样简化的做法呢？因为一方面的确也能取得不错的效果，另一方面是深度学习和推荐系统还迟迟没有相见。</p><p>在深度学习大火之后，对时间序列建模被提上议事日程，业界有很多尝试，今天以Spotify的音乐推荐为例，介绍循环神经网络在推荐系统中的应用。</p><h2 id="循环神经网络" tabindex="-1"><a class="header-anchor" href="#循环神经网络"><span>循环神经网络</span></a></h2><p>循环神经网络，也常被简称为RNN，是一种特殊的神经网络。再回顾一下神经网络的结构，示意图如下：</p><img src="https://static001.geekbang.org/resource/image/61/c6/61177f813f5f493966f8f9beaa395dc6.png" alt=""><p>普通神经网络有三个部分，输入层x，隐藏层h，输出层o，深度神经网络的区别就是隐藏层数量有很多，具体多少算深，这个可没有定论，有几层的，也有上百层的。</p><p>把输入层和隐藏层之间的关系表示成公式后就是：</p><p>$$h = F(Wx) $$</p><p>就是输入层x经过连接参数线性加权后，再有激活函数F变换成非线性输出给输出层。</p><p>在输出层就是：</p><p>$$O = \\phi(Vh) $$</p><p>隐藏层输出经过输出层的网络连接参数线性加权后，再由输出函数变换成最终输出，比如分类任务就是Softmax函数。</p><p>那循环神经网络和普通神经网络的区别在哪？</p><p>区别就在于：普通神经网络的隐藏层参数只有输入x决定，因为当神经网络在面对一条样本时，这条样本是孤立的，不考虑前一个样本是什么，循环神经网络的隐藏层不只是受输入x影响，还受上一个时刻的隐藏层参数影响。</p><p>我们把这个表示成示意图如下：<br><br><img src="https://static001.geekbang.org/resource/image/28/71/285fdbb62e517ddb2099d3b6c87f8371.png" alt=""></p><p>解释一下这个示意图。在时刻t，输入是xt，而隐藏层的输出不再是只有输入层xt，还有时刻t-1的隐藏层输出h(t-1)，表示成公式就是：</p><p>$$h_{t} = F(Wx_{t} + Uh_{t-1})$$</p><p>对比这个公式和前面普通神经网络的隐藏层输出，就是在激活函数的输入处多了一个 $Uh_{t-1}$ 。别小看多这一个小东西，它背后的意义非凡。</p><p>我一直在传递一个观点，隐藏层的东西，包括矩阵分解和各种Embedding得到的隐因子，是对很多表面纷繁复杂的现象所做的信息抽取和信息压缩。</p><p>那么上一个时刻得到的隐藏层，就是对时间序列上一个时刻的信息压缩，让它参与到这一个时刻的隐藏层建设上来，物理意义就是认为现在这个时刻的信息不只和现在的输入有关，还和上一个时刻的状态有关。这是时间序列本来的意义，也就是循环神经网络的意义。</p><h2 id="播单生成" tabindex="-1"><a class="header-anchor" href="#播单生成"><span>播单生成</span></a></h2><p>了解了循环神经网络原理之后，我再和你一起来看下它如何应用在推荐系统中的。</p><p>在网络音乐推荐中，尤其是各类FM类App，提倡的是一直听下去，比如是你在做家务时，你在开车时，一首歌接着一首歌地播下去，就很适合这些场景。</p><p>通常要做到这样的效果，有这么几种做法。</p><ol><li>电台音乐DJ手工编排播单，然后一直播放下去，传统广播电台都是这样的。</li><li>用非时序数据离线计算出推荐集合，然后按照分数顺序逐一输出。</li><li>利用循环神经网络，把音乐播单的生成看成是歌曲时间序列的生成，每一首歌的得到不但受用户当前的特征影响，还受上一首歌影响。</li></ol><p>Spotify采用了第三种办法，下面我就详细讲解这个推荐算法。</p><h3 id="_1-数据" tabindex="-1"><a class="header-anchor" href="#_1-数据"><span>1.数据</span></a></h3><p>个性化的播单生成，不再是推荐一个一个独立的音乐，而是推荐一个序列给用户。所用的数据就是已有播单，或者用户的会话信息。其中用户会话信息的意思就是，当一个用户在App上所做的一系列操作。</p><p>把这些数据，看成一个一个的文档，每一个音乐文件就是一个一个的词。听完什么再听什么，就像是语言中的词和词的关系。</p><h3 id="_2-建模" tabindex="-1"><a class="header-anchor" href="#_2-建模"><span>2.建模</span></a></h3><p>你可以把播单生成看成由若干步骤组成，每一步吐出一个音乐来。这个吐出音乐的动作实际上是一个多分类问题，类别数目就是总共可以选择的音乐数目，如果有100万首歌可以选择，那么就是一个100万分类任务。</p><p>这个分类任务计算输入是当前神经网络的隐藏状态，然后每一首歌都得到一个线性加权值，再由Softmax函数为每一首歌计算得到一个概率。表示如下：</p><p>$$p(o_{ti} | h_{t}) = \\frac{e^{v_{i}h} }{\\sum_{j \\in M}{e^{v_{j}h} }} $$</p><p>假如隐藏层有k个神经元，也就是说h是一个k维向量，输出层有m首歌可选，所以是一个One-hot编码的向量，也就是说一个m维向量，只有真正输出那首歌i是1，其他都是0，那么输出层就有k乘以m个未知参数。</p><p>再往前，计算隐藏层神经元输出时，不但用到输入层的信息，在这里，输入层也是一首歌，也有m首歌可以选择，所以输入向量仍然是一个One-hot编码的向量。</p><p>除此之外，每一个隐藏层神经元还依赖上一个时刻自己的输出值，隐藏层神经元是k个，一个k维向量。</p><p>按照隐藏层计算公式就是下面的样子。</p><p>$$h_{t} = F(Wx_{t} + Uh_{t-1})$$</p><p>W就是一个m乘以k的参数矩阵，U就是一个k乘以k的参数矩阵。</p><p>如此一来，循环神经网络在预测时的计算过程就是：</p><p>当用户听完一首歌，要预测下一首歌该推荐什么时，输入就是一个One-hot编码的m维度向量，用m乘以k形状的输入层参数矩阵，乘以这个m向量，然后用隐藏层之间的k乘k参数矩阵，去乘以上一个隐藏状态向量，两者都得到一个k维向量，相加后经过非线性激活函数，比如ReLU，这样就得到当前时刻的隐藏层输出值。</p><p>再用当前时刻的隐藏层输出值，经过k乘以m形状的输出层参数矩阵，得到一个m维向量，再用Softmax把这个m维向量归一化成概率值，就是对下一首歌的预测，可以挑选最大概率的若干首歌作为输出，或者直接输出概率最高的那首歌直接播放。</p><p>这个计算过程示意图如下：</p><img src="https://static001.geekbang.org/resource/image/79/28/79e67fc2dd3172dd1e331d6ebd5e9a28.png" alt=""><p>一个播单生成模型的参数就是这么三大块。</p><ol><li>连接输入和隐藏之间的矩阵 $W_{m\\times{k} }$；</li><li>连接上一个隐藏状态和当前隐藏状态的矩阵： $U_{k \\times {k} }$；</li><li>连接隐藏层和输出层的矩阵 $V_{k\\times{m} }$。</li></ol><p>得到了这些参数，就得到了播单推荐模型，怎么得到呢？这里就再简要讲一下神经网络的参数如何训练得到。</p><p>你知道一个简单的逻辑回归模型参数如何训练得到吗？大致是这样几步：</p><ol><li>初始化参数；</li><li>用当前的参数预测样本的类别概率；</li><li>用预测的概率计算交叉熵；</li><li>用交叉熵计算参数的梯度；</li><li>用学习步长和梯度更新参数；</li><li>迭代上述过程直到满足设置的条件。</li></ol><p>神经网络的参数学习大致也是这个过程，但略为复杂的地方就是第4步和第5步，因为逻辑回归没有隐藏层，神经网络有隐藏层。那怎么办呢？我不打算讲解具体的做法，我打算给你建立一个直观印象。</p><p>还记得下面这个函数对x求导是怎么计算的吗？</p><p>$$f(x) = g(x)^2;$$</p><p>$$g(x) = e^x$$</p><p>函数f(x)是另一个函数gx的平方，函数g(x)又是一个指数函数。那么要对f(x0求导，就是一个链式规则，先把g(x)看成个一个整体求导，再乘以g(x)的求导结果：</p>',60),t("p",null,[a("$$f^{’}(x) = 2g(x)e^{x} = 2e"),t("sup",{x:""},"{x}e"),a(" = 2e^{2x}$$")],-1),e('<p>你就需要记住一点：链式规则，一路求导下去。</p><p>现在回到神经网路的训练，这个方法有个高大上的名字，叫做误差方向传播。</p><p>实际上就是链式求导法则，因为要更新参数，就需要计算参数在当前取值时的梯度，要计算梯度就要求导，要求导就要从交叉熵函数开始，先对输出层参数求导计算梯度，更新输出层参数，接着链式下去，对输入层参数求导计算梯度，更新输入层参数。</p><p>交叉熵是模型的目标函数，训练模型的目的就是要最小化它，也就是“误差反向传播”的“误差”。</p><p>相信聪明如你已经在直观上理解了一个普通神经网络是怎么训练的了，那么一个循环神经网络的参数训练有何不同呢？唯一不同就是多了一个参数矩阵，连接当前隐藏层和上一次隐藏层的参数矩阵U，也是链式求导法则的传播路径，也就是多了一些求导计算，更新参数方式并没有什么不同。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>好了，今天介绍了如何使用循环神经网络推荐音乐播单，播单是一个时间序列，听完上一首歌会影响下一首歌。</p><p>循环神经网络和普通神经网络相比，就是在两个时刻的隐藏状态之间多了网络连接。看上去这个网络连接只与上一个时刻有关，事实上，上一个状态又与上上个状态有关，所以实际上任意一个时刻的状态是与此前所有的状态有关的。</p><p>今天的应用虽然是以播单推荐为例，但其实循环神经网络还可以应用在很多其他地方，你对循环神经网络的应用有任何问题都可以留言给我，我们一起讨论。</p><p>感谢你的收听，我们下期再见。</p><img src="https://static001.geekbang.org/resource/image/10/50/1025014d381c4913aae6eaef553d7750.jpg" alt="">',11)]))}const l=i(n,[["render",s]]),m=JSON.parse('{"path":"/posts/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%B8%89%E5%8D%81%E5%85%AD%E5%BC%8F/%E5%8E%9F%E7%90%86%E7%AF%87%20%C2%B7%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/20%20_%20%E7%94%A8RNN%E6%9E%84%E5%BB%BA%E4%B8%AA%E6%80%A7%E5%8C%96%E9%9F%B3%E4%B9%90%E6%92%AD%E5%8D%95.html","title":"20 _ 用RNN构建个性化音乐播单","lang":"zh-CN","frontmatter":{"description":"20 _ 用RNN构建个性化音乐播单 时间是一个客观存在的物理属性，很多数据都有时间属性，只不过大多时候都把它忽略掉了。前面讲到的绝大多数推荐算法，也都没有考虑“用户在产品上作出任何行为”都是有时间先后的。 正是认识到这一点，有一些矩阵分解算法考虑了时间属性，比如Time-SVD；但是，这种做法只是把时间作为一个独立特征加入到模型中，仍然没有给时间一个...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/interview/posts/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%B8%89%E5%8D%81%E5%85%AD%E5%BC%8F/%E5%8E%9F%E7%90%86%E7%AF%87%20%C2%B7%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/20%20_%20%E7%94%A8RNN%E6%9E%84%E5%BB%BA%E4%B8%AA%E6%80%A7%E5%8C%96%E9%9F%B3%E4%B9%90%E6%92%AD%E5%8D%95.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"20 _ 用RNN构建个性化音乐播单"}],["meta",{"property":"og:description","content":"20 _ 用RNN构建个性化音乐播单 时间是一个客观存在的物理属性，很多数据都有时间属性，只不过大多时候都把它忽略掉了。前面讲到的绝大多数推荐算法，也都没有考虑“用户在产品上作出任何行为”都是有时间先后的。 正是认识到这一点，有一些矩阵分解算法考虑了时间属性，比如Time-SVD；但是，这种做法只是把时间作为一个独立特征加入到模型中，仍然没有给时间一个..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-16T11:19:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-16T11:19:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"20 _ 用RNN构建个性化音乐播单\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-16T11:19:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755343178000,"updatedTime":1755343178000,"contributors":[{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":1,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":10.3,"words":3090},"filePathRelative":"posts/推荐系统三十六式/原理篇 · 深度学习/20 _ 用RNN构建个性化音乐播单.md","localizedDate":"2025年8月16日","excerpt":"\\n<p><audio id=\\"audio\\" title=\\"20 | 用RNN构建个性化音乐播单\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/8a/10/8ab8d1628502c5b54cbc68bc9d171210.mp3\\"></audio></p>\\n<p>时间是一个客观存在的物理属性，很多数据都有时间属性，只不过大多时候都把它忽略掉了。前面讲到的绝大多数推荐算法，也都没有考虑“用户在产品上作出任何行为”都是有时间先后的。</p>\\n<p>正是认识到这一点，有一些矩阵分解算法考虑了时间属性，比如Time-SVD；但是，这种做法只是把时间作为一个独立特征加入到模型中，仍然没有给时间一个正确的名分。</p>","autoDesc":true}');export{l as comp,m as data};
