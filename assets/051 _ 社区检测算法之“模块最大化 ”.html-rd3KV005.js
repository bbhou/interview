import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as o,o as n}from"./app-d8EKP-K0.js";const r={};function p(s,t){return n(),a("div",null,t[0]||(t[0]=[o('<h1 id="_051-社区检测算法之-模块最大化" tabindex="-1"><a class="header-anchor" href="#_051-社区检测算法之-模块最大化"><span>051 _ 社区检测算法之“模块最大化 ”</span></a></h1><p><audio id="audio" title="051 | 社区检测算法之“模块最大化 ”" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/17/a3/177cf689c0b00f8ce67cc46427b3aea3.mp3"></audio></p><p>一起来回顾下本周的内容。周一我们介绍了用图（Graph）来表达网页与网页之间的关系并计算网页的重要性，就是经典的PageRank算法。周三我们介绍了PageRank的一个姊妹算法，HITS算法，并且分析了这两种算法的内在联系，这两类算法都希望给网页赋予一个权重来表达网页的重要性。</p><p>今天，我们来看一类完全不一样的网页分析工具，那就是希望把网页所代表的图分割成小块的图，或者叫图聚类，每个小聚类代表一个“社区”。这类分析有时候被称作图上面的“<strong>社区检测</strong>”（Community Detection），意思就是从一个图上挖掘出潜在的社区结构。</p><h2 id="社区检测的简要历史" tabindex="-1"><a class="header-anchor" href="#社区检测的简要历史"><span>社区检测的简要历史</span></a></h2><p>提到社区检测就不得不提到这么一位学者，他与我们今天要介绍的算法有非常紧密的联系，而且他的研究在2000年~2010年间成了社区检测研究的标杆，影响了后续的大量研究工作。这位学者就是密歇根大学（University of Michigan）的物理学教授马克·纽曼（Mark Newman）。</p><p>1991年，纽曼从牛津大学获得理论物理博士学位。在接下来的10年里，他在康奈尔大学和圣塔菲学院（Santa Fe Institute）分别担任博士后研究员和研究教授。2002年，纽曼来到密歇根大学物理系担任教授，并且一直在这里进行网络科学（Network Science）的基础研究。</p><p>2006年，纽曼在《物理评论》杂志上发表了一个叫“<strong>模块最大化</strong>”（Modularity Maximization）的社区检测算法。从某种程度上来说，这个算法很快就成了社区检测的标准算法，吸引了研究领域的广泛关注，激发了大量的针对这个算法的分析和研究。对这个算法的最原始论述，请参阅参考文献[1]和[2]。</p><p>今天我们就来讲一讲这个“模块最大化”算法的基本原理。</p><h2 id="模块最大化的基本原理" tabindex="-1"><a class="header-anchor" href="#模块最大化的基本原理"><span>模块最大化的基本原理</span></a></h2><p>在我们讲解模块最大化算法之前，我们先来看一看“社区”的含义。在图分析以及网络科学中，<strong>“社区”定义为一组结点，它们互相之间的联系比它们跟社区之外结点的联系要更加紧密</strong>。你可以注意到，在这个定义中，什么叫紧密，怎么来衡量“更紧密”这个关系都是没有说明的，这就为各类社区检测算法或模型带来了很大的发挥空间。</p><p>社区检测（有时候也说社区发掘）算法的核心就是要<strong>根据给定的一组结点和它们之间的关系，在无监督的情况找到这些社区，并分配哪些结点属于哪个社区</strong>。</p><p>我们先来谈一谈**“模块最大化”的一个整体思路**。这里，我们讨论一种简化的情况，那就是如何把一个网络分割成两个社区。首先，算法按照某种随机的初始化条件，把网络分成两个社区。然后，算法逐一检查每一个结点，看如果把这个点划归到另外一个社区的话，会不会增加“模块化”这个目标函数。最终，算法决定改变那些能够最大化模块化目标的结点的社区赋值。然后整个算法不断重复这个过程，直到社区的赋值不再发生变化。</p><p>现在我们来讨论一下模块化这个目标函数。根据上面提到的社区含义，我们希望社区里结点之间的联系紧密。<strong>在模块化目标函数里，就表达为两个结点的连接数目减去这两个结点之间的“期望连接数”</strong>。模块化最大化说的就是，对于同一个社区中的所有结点，我们希望这个差值的和最大化。什么意思呢？就是说，如果我们把两个结点放到一个社区中，那它们的连接数（其实就是1或者0）要足够大于它们之间的连接数的期望值，这就解决了我们刚才所说的如何来衡量“更加紧密”的难题。</p><p>那么，怎么来定义两个结点之间的“期望连接数”呢？最初纽曼在介绍模块最大化的时候，他给出了这么一个计算方法。那就是，用两个结点各自的总连接数相乘，除以整个网络的总连接数的2倍。直观上说，这是在衡量这两个结点之间出现任何连接的可能性。</p><p>那么，整个模块最大化的目标函数就是，针对现在网络中的所有结点，根据它们是否在同一个社区，我们计算他们两两之间的模块化数值，也就是它们之间的连接减去“期望连接数”，最后对所有的两两配对进行加和。我们希望这个目标函数最大化，这个目标函数中的未知数，就是社区的分配，也就是哪个结点属于哪个社区。一旦社区的分配已知，整个模块最大化这个目标函数的数值就可以很容易地计算出来。</p><p>那么如何得到这些社区的分配呢？和我们之前介绍的PageRank以及HITS的思路类似，纽曼使用了矩阵的表达方法对整个模块最大化进行了一个重构，经过一系列代数变形之后[1]，纽曼得到了一个新的目标函数，那就是一个向量s的转置，乘以一个矩阵B，然后再乘以向量s，最后除以4倍的网络连接总数。这里，向量s代表了一个结点是否属于两个社区中的一个，矩阵B中的每一个元素表示了横纵坐标所代表的两个结点的模块化值。问题就是求解s的值。请注意，s中的值是离散的，要么是正1（代表属于两个社区中的一个）要么是负1（代表属于两个社区中的另一个）。很明显，这是一个困难的离散优化问题。</p><p><strong>纽曼对这个复杂的离散优化问题进行了近似处理的方法</strong>。具体来说，那就是允许s的值不仅仅是正负1而是实数，这样就大大简化了优化问题的难度。在设置好最优化这个新的目标函数之后，经过代数变形，我们得到了一个惊人的结论，那就是最优情况下的s，实际就是矩阵B最大的特征值所对应的特征向量。这又和PageRank以及HITS有着极其相似的最优结构。在找最大特征向量的过程中找到s以后，我们就根据s里元素的正负号，正的属于一个社区，负的属于另外一个社区，来对整个网络中的结点进行划分。</p><p>当然，我们这里讲的仅仅是把整个网络进行二分的情况。在实际应用中，我们往往需要把整个网络划分成多个社区。纽曼在论文中[1]也讲解了<strong>如何把二分法推广到多个社区的情景</strong>。具体来说，就是先把一个网络分成两份，然后再不断地二分下去。不过，每次进行二分的时候，我们都需要检查是否对模块化目标函数起了正向的帮助，而不只是机械地进行二分。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><p>今天我为你讲了社区检测中一个有代表性的算法：模块最大化 。 一起来回顾下要点：第一，我们讲了什么是社区检测以及社区检测的一些简明历史。第二，我们讲了模块最大化的的基本思想，比如模块最大化是如何定义的，又是如何把一个困难的离散优化问题转换成类似HITS和PageRank的寻找最大特征向量的问题 。</p><p>最后，给你留一个思考题，如何把网页的社区信息利用到学习网页的相关度里面去呢？</p><p>欢迎你给我留言，和我一起讨论。</p><p><strong>参考文献</strong></p><ol><li>M. E. J. Newman. <strong>Modularity and community structure in networks</strong>. Proc. Natl. Acad. Sci. USA 103, 8577–8582 , 2006.</li><li>M. E. J. Newman. <strong>Finding community structure in networks using the eigenvectors of matrices</strong>. Phys. Rev. E 74, 036104 , 2006.</li></ol><p><strong>论文链接</strong></p><ol><li><a href="http://www.pnas.org/content/103/23/8577.full.pdf" target="_blank" rel="noopener noreferrer">Modularity and community structure in networks</a></li><li><a href="https://arxiv.org/pdf/physics/0605087.pdf" target="_blank" rel="noopener noreferrer">Finding community structure in networks using the eigenvectors of matrices</a></li></ol>',27)]))}const g=e(r,[["render",p]]),d=JSON.parse('{"path":"/posts/AI%E6%8A%80%E6%9C%AF%E5%86%85%E5%8F%82/%E6%90%9C%E7%B4%A2%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/051%20_%20%E7%A4%BE%E5%8C%BA%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E4%B9%8B%E2%80%9C%E6%A8%A1%E5%9D%97%E6%9C%80%E5%A4%A7%E5%8C%96%20%E2%80%9D.html","title":"051 _ 社区检测算法之“模块最大化 ”","lang":"zh-CN","frontmatter":{"description":"051 _ 社区检测算法之“模块最大化 ” 一起来回顾下本周的内容。周一我们介绍了用图（Graph）来表达网页与网页之间的关系并计算网页的重要性，就是经典的PageRank算法。周三我们介绍了PageRank的一个姊妹算法，HITS算法，并且分析了这两种算法的内在联系，这两类算法都希望给网页赋予一个权重来表达网页的重要性。 今天，我们来看一类完全不一样...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/interview/posts/AI%E6%8A%80%E6%9C%AF%E5%86%85%E5%8F%82/%E6%90%9C%E7%B4%A2%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/051%20_%20%E7%A4%BE%E5%8C%BA%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E4%B9%8B%E2%80%9C%E6%A8%A1%E5%9D%97%E6%9C%80%E5%A4%A7%E5%8C%96%20%E2%80%9D.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"051 _ 社区检测算法之“模块最大化 ”"}],["meta",{"property":"og:description","content":"051 _ 社区检测算法之“模块最大化 ” 一起来回顾下本周的内容。周一我们介绍了用图（Graph）来表达网页与网页之间的关系并计算网页的重要性，就是经典的PageRank算法。周三我们介绍了PageRank的一个姊妹算法，HITS算法，并且分析了这两种算法的内在联系，这两类算法都希望给网页赋予一个权重来表达网页的重要性。 今天，我们来看一类完全不一样..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-16T11:19:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-16T11:19:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"051 _ 社区检测算法之“模块最大化 ”\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-16T11:19:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755343178000,"updatedTime":1755343178000,"contributors":[{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":1,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":7.61,"words":2283},"filePathRelative":"posts/AI技术内参/搜索核心技术/051 _ 社区检测算法之“模块最大化 ”.md","localizedDate":"2025年8月16日","excerpt":"\\n<p><audio id=\\"audio\\" title=\\"051 | 社区检测算法之“模块最大化 ”\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/17/a3/177cf689c0b00f8ce67cc46427b3aea3.mp3\\"></audio></p>\\n<p>一起来回顾下本周的内容。周一我们介绍了用图（Graph）来表达网页与网页之间的关系并计算网页的重要性，就是经典的PageRank算法。周三我们介绍了PageRank的一个姊妹算法，HITS算法，并且分析了这两种算法的内在联系，这两类算法都希望给网页赋予一个权重来表达网页的重要性。</p>","autoDesc":true}');export{g as comp,d as data};
