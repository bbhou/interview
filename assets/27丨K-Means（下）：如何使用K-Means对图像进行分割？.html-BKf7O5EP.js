import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as e,o as i}from"./app-d8EKP-K0.js";const p={};function l(r,s){return i(),n("div",null,s[0]||(s[0]=[e(`<h1 id="_27丨k-means-下-如何使用k-means对图像进行分割" tabindex="-1"><a class="header-anchor" href="#_27丨k-means-下-如何使用k-means对图像进行分割"><span>27丨K-Means（下）：如何使用K-Means对图像进行分割？</span></a></h1><p><audio id="audio" title="27丨K-Means（下）：如何使用K-Means对图像进行分割？" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/68/32/68974aaf0975c8e01c9dab7897c2a732.mp3"></audio></p><p>上节课，我讲解了K-Means的原理，并且用K-Means对20支亚洲球队进行了聚类，分成3个梯队。今天我们继续用K-Means进行聚类的实战。聚类的一个常用场景就是对图像进行分割。</p><p>图像分割就是利用图像自身的信息，比如颜色、纹理、形状等特征进行划分，将图像分割成不同的区域，划分出来的每个区域就相当于是对图像中的像素进行了聚类。单个区域内的像素之间的相似度大，不同区域间的像素差异性大。这个特性正好符合聚类的特性，所以你可以把图像分割看成是将图像中的信息进行聚类。当然聚类只是分割图像的一种方式，除了聚类，我们还可以基于图像颜色的阈值进行分割，或者基于图像边缘的信息进行分割等。</p><h2 id="将微信开屏封面进行分割" tabindex="-1"><a class="header-anchor" href="#将微信开屏封面进行分割"><span>将微信开屏封面进行分割</span></a></h2><p>上节课，我讲了sklearn工具包中的K-Means算法使用，我们现在用K-Means算法对微信页面进行分割。微信开屏图如下所示：</p><p><img src="https://static001.geekbang.org/resource/image/50/a2/50457e4e1fbd288c125364a6904774a2.png" alt=""><br><br> 我们先设定下聚类的流程，聚类的流程和分类差不多，如图所示：</p><p><img src="https://static001.geekbang.org/resource/image/8a/78/8af94562f6bd3ac42036ec47f5ad2578.jpg" alt=""><br><br> 在准备阶段里，我们需要对数据进行加载。因为处理的是图像信息，我们除了要获取图像数据以外，还需要获取图像的尺寸和通道数，然后基于图像中每个通道的数值进行数据规范化。这里我们需要定义个函数load_data，来帮我们进行图像加载和数据规范化。代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span># 加载图像，并对数据进行规范化</span></span>
<span class="line"><span>def load_data(filePath):</span></span>
<span class="line"><span>    # 读文件</span></span>
<span class="line"><span>    f = open(filePath,&#39;rb&#39;)</span></span>
<span class="line"><span>    data = []</span></span>
<span class="line"><span>    # 得到图像的像素值</span></span>
<span class="line"><span>    img = image.open(f)</span></span>
<span class="line"><span>    # 得到图像尺寸</span></span>
<span class="line"><span>    width, height = img.size</span></span>
<span class="line"><span>    for x in range(width):</span></span>
<span class="line"><span>        for y in range(height):</span></span>
<span class="line"><span>            # 得到点(x,y)的三个通道值</span></span>
<span class="line"><span>            c1, c2, c3 = img.getpixel((x, y))</span></span>
<span class="line"><span>            data.append([c1, c2, c3])</span></span>
<span class="line"><span>    f.close()</span></span>
<span class="line"><span>    # 采用Min-Max规范化</span></span>
<span class="line"><span>    mm = preprocessing.MinMaxScaler()</span></span>
<span class="line"><span>    data = mm.fit_transform(data)</span></span>
<span class="line"><span>    return np.mat(data), width, height</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为jpg格式的图像是三个通道(R,G,B)，也就是一个像素点具有3个特征值。这里我们用c1、c2、c3来获取平面坐标点(x,y)的三个特征值，特征值是在0-255之间。</p><p>为了加快聚类的收敛，我们需要采用Min-Max规范化对数据进行规范化。我们定义的load_data函数返回的结果包括了针对(R,G,B)三个通道规范化的数据，以及图像的尺寸信息。在定义好load_data函数后，我们直接调用就可以得到相关信息，代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span># 加载图像，得到规范化的结果img，以及图像尺寸</span></span>
<span class="line"><span>img, width, height = load_data(&#39;./weixin.jpg&#39;)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>假设我们想要对图像分割成2部分，在聚类阶段，我们可以将聚类数设置为2，这样图像就自动聚成2类。代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span># 用K-Means对图像进行2聚类</span></span>
<span class="line"><span>kmeans =KMeans(n_clusters=2)</span></span>
<span class="line"><span>kmeans.fit(img)</span></span>
<span class="line"><span>label = kmeans.predict(img)</span></span>
<span class="line"><span># 将图像聚类结果，转化成图像尺寸的矩阵</span></span>
<span class="line"><span>label = label.reshape([width, height])</span></span>
<span class="line"><span># 创建个新图像pic_mark，用来保存图像聚类的结果，并设置不同的灰度值</span></span>
<span class="line"><span>pic_mark = image.new(&amp;quot;L&amp;quot;, (width, height))</span></span>
<span class="line"><span>for x in range(width):</span></span>
<span class="line"><span>    for y in range(height):</span></span>
<span class="line"><span>        # 根据类别设置图像灰度, 类别0 灰度值为255， 类别1 灰度值为127</span></span>
<span class="line"><span>        pic_mark.putpixel((x, y), int(256/(label[x][y]+1))-1)</span></span>
<span class="line"><span>pic_mark.save(&amp;quot;weixin_mark.jpg&amp;quot;, &amp;quot;JPEG&amp;quot;)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码中有一些参数，我来给你讲解一下这些参数的作用和设置方法。</p><p>我们使用了fit和predict这两个函数来做数据的训练拟合和预测，因为传入的参数是一样的，我们可以同时进行fit和predict操作，这样我们可以直接使用fit_predict(data)得到聚类的结果。得到聚类的结果label后，实际上是一个一维的向量，我们需要把它转化成图像尺寸的矩阵。label的聚类结果是从0开始统计的，当聚类数为2的时候，聚类的标识label=0或者1。</p><p>如果你想对图像聚类的结果进行可视化，直接看0和1是看不出来的，还需要将0和1转化为灰度值。灰度值一般是在0-255的范围内，我们可以将label=0设定为灰度值255，label=1设定为灰度值127。具体方法是用int(256/(label[x][y]+1))-1。可视化的时候，主要是通过设置图像的灰度值进行显示。所以我们把聚类label=0的像素点都统一设置灰度值为255，把聚类label=1的像素点都统一设置灰度值为127。原来图像的灰度值是在0-255之间，现在就只有2种颜色（也就是灰度为255，和灰度127）。</p><p>有了这些灰度信息，我们就可以用image.new创建一个新的图像，用putpixel函数对新图像的点进行灰度值的设置，最后用save函数保存聚类的灰度图像。这样你就可以看到聚类的可视化结果了，如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/94/6b/9420b9bedf2e3514b0624543a69fb06b.png" alt=""><br><br> 上面是分割成2个部分的分割可视化，完整代码见<a href="https://github.com/cystanford/kmeans/blob/master/kmeans1.py" target="_blank" rel="noopener noreferrer">这里</a>。</p><p><a href="https://github.com/cystanford/kmeans/blob/master/kmeans1.py" target="_blank" rel="noopener noreferrer">https://github.com/cystanford/kmeans/blob/master/kmeans1.py</a></p><p>如果我们想要分割成16个部分，该如何对不同分类设置不同的颜色值呢？这里需要用到skimage工具包，它是图像处理工具包。你需要使用pip install scikit-image来进行安装。</p><p>这段代码可以将聚类标识矩阵转化为不同颜色的矩阵：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>from skimage import color</span></span>
<span class="line"><span># 将聚类标识矩阵转化为不同颜色的矩阵</span></span>
<span class="line"><span>label_color = (color.label2rgb(label)*255).astype(np.uint8)</span></span>
<span class="line"><span>label_color = label_color.transpose(1,0,2)</span></span>
<span class="line"><span>images = image.fromarray(label_color)</span></span>
<span class="line"><span>images.save(&#39;weixin_mark_color.jpg&#39;)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码中，我使用skimage中的label2rgb函数来将label分类标识转化为颜色数值，因为我们的颜色值范围是[0,255]，所以还需要乘以255进行转化，最后再转化为np.uint8类型。unit8类型代表无符号整数，范围是0-255之间。</p><p>得到颜色矩阵后，你可以把它输出出来，这时你发现输出的图像是颠倒的，原因可能是图像源拍摄的时候本身是倒置的。我们需要设置三维矩阵的转置，让第一维和第二维颠倒过来，也就是使用transpose(1,0,2)，将原来的(0,1,2）顺序转化为(1,0,2)顺序，即第一维和第二维互换。</p><p>最后我们使用fromarray函数，它可以通过矩阵来生成图片，并使用save进行保存。</p><p>最后得到的分类标识颜色化图像是这样的：</p><p><img src="https://static001.geekbang.org/resource/image/d2/b7/d26df5f1ed26cca53118a99aa04484b7.png" alt=""><br><br> 完整的代码见<a href="https://github.com/cystanford/kmeans/blob/master/kmeans2.py" target="_blank" rel="noopener noreferrer">这里</a>。</p><p><a href="https://github.com/cystanford/kmeans/blob/master/kmeans2.py" target="_blank" rel="noopener noreferrer">https://github.com/cystanford/kmeans/blob/master/kmeans2.py</a></p><p>刚才我们做的是聚类的可视化。如果我们想要看到对应的原图，可以将每个簇（即每个类别）的点的RGB值设置为该簇质心点的RGB值，也就是簇内的点的特征均为质心点的特征。</p><p>我给出了完整的代码，代码中，我可以把范围为0-255的数值投射到1-256数值之间，方法是对每个数值进行加1，你可以自己来运行下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span># -*- coding: utf-8 -*-</span></span>
<span class="line"><span># 使用K-means对图像进行聚类，并显示聚类压缩后的图像</span></span>
<span class="line"><span>import numpy as np</span></span>
<span class="line"><span>import PIL.Image as image</span></span>
<span class="line"><span>from sklearn.cluster import KMeans</span></span>
<span class="line"><span>from sklearn import preprocessing</span></span>
<span class="line"><span>import matplotlib.image as mpimg</span></span>
<span class="line"><span># 加载图像，并对数据进行规范化</span></span>
<span class="line"><span>def load_data(filePath):</span></span>
<span class="line"><span>    # 读文件</span></span>
<span class="line"><span>    f = open(filePath,&#39;rb&#39;)</span></span>
<span class="line"><span>    data = []</span></span>
<span class="line"><span>    # 得到图像的像素值</span></span>
<span class="line"><span>    img = image.open(f)</span></span>
<span class="line"><span>    # 得到图像尺寸</span></span>
<span class="line"><span>    width, height = img.size</span></span>
<span class="line"><span>    for x in range(width):</span></span>
<span class="line"><span>        for y in range(height):</span></span>
<span class="line"><span>            # 得到点(x,y)的三个通道值</span></span>
<span class="line"><span>            c1, c2, c3 = img.getpixel((x, y))</span></span>
<span class="line"><span>            data.append([(c1+1)/256.0, (c2+1)/256.0, (c3+1)/256.0])</span></span>
<span class="line"><span>    f.close()</span></span>
<span class="line"><span>    return np.mat(data), width, height</span></span>
<span class="line"><span># 加载图像，得到规范化的结果imgData，以及图像尺寸</span></span>
<span class="line"><span>img, width, height = load_data(&#39;./weixin.jpg&#39;)</span></span>
<span class="line"><span># 用K-Means对图像进行16聚类</span></span>
<span class="line"><span>kmeans =KMeans(n_clusters=16)</span></span>
<span class="line"><span>label = kmeans.fit_predict(img)</span></span>
<span class="line"><span># 将图像聚类结果，转化成图像尺寸的矩阵</span></span>
<span class="line"><span>label = label.reshape([width, height])</span></span>
<span class="line"><span># 创建个新图像img，用来保存图像聚类压缩后的结果</span></span>
<span class="line"><span>img=image.new(&#39;RGB&#39;, (width, height))</span></span>
<span class="line"><span>for x in range(width):</span></span>
<span class="line"><span>    for y in range(height):</span></span>
<span class="line"><span>        c1 = kmeans.cluster_centers_[label[x, y], 0]</span></span>
<span class="line"><span>        c2 = kmeans.cluster_centers_[label[x, y], 1]</span></span>
<span class="line"><span>        c3 = kmeans.cluster_centers_[label[x, y], 2]</span></span>
<span class="line"><span>        img.putpixel((x, y), (int(c1*256)-1, int(c2*256)-1, int(c3*256)-1))</span></span>
<span class="line"><span>img.save(&#39;weixin_new.jpg&#39;)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>完整代码见<a href="https://github.com/cystanford/kmeans/blob/master/kmeans3.py" target="_blank" rel="noopener noreferrer">这里</a>。</p><p><a href="https://github.com/cystanford/kmeans/blob/master/kmeans3.py" target="_blank" rel="noopener noreferrer">https://github.com/cystanford/kmeans/blob/master/kmeans3.py</a></p><p>你可以看到我没有用到sklearn自带的MinMaxScaler，而是自己写了Min-Max规范化的公式。这样做的原因是我们知道RGB每个通道的数值在[0,255]之间，所以我们可以用每个通道的数值+1/256，这样数值就会在[0,1]之间。</p><p>对图像做了Min-Max空间变换之后，还可以对其进行反变换，还原出对应原图的通道值。</p><p>对于点(x,y)，我们找到它们所属的簇label[x,y]，然后得到这个簇的质心特征，用c1,c2,c3表示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>c1 = kmeans.cluster_centers_[label[x, y], 0]</span></span>
<span class="line"><span>c2 = kmeans.cluster_centers_[label[x, y], 1]</span></span>
<span class="line"><span>c3 = kmeans.cluster_centers_[label[x, y], 2]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为c1, c2, c3对应的是数据规范化的数值，因此我们还需要进行反变换，即：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>c1=int(c1*256)-1</span></span>
<span class="line"><span>c2=int(c2*256)-1</span></span>
<span class="line"><span>c3=int(c3*256)-1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后用img.putpixel设置点(x,y)反变换后得到的特征值。最后用img.save保存图像。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>今天我们用K-Means做了图像的分割，其实不难发现K-Means聚类有个缺陷：聚类个数K值需要事先指定。如果你不知道该聚成几类，那么最好会给K值多设置几个，然后选择聚类结果最好的那个值。</p><p>通过今天的图像分割，你发现用K-Means计算的过程在sklearn中就是几行代码，大部分的工作还是在预处理和后处理上。预处理是将图像进行加载，数据规范化。后处理是对聚类后的结果进行反变换。</p><p>如果涉及到后处理，你可以自己来设定数据规范化的函数，这样反变换的函数比较容易编写。</p><p>另外我们还学习了如何在Python中如何对图像进行读写，具体的代码如下，上文中也有相应代码，你也可以自己对应下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>import PIL.Image as image</span></span>
<span class="line"><span># 得到图像的像素值</span></span>
<span class="line"><span>img = image.open(f)</span></span>
<span class="line"><span># 得到图像尺寸</span></span>
<span class="line"><span>width, height = img.size</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里会使用PIL这个工具包，它的英文全称叫Python Imaging Library，顾名思义，它是Python图像处理标准库。同时我们也使用到了skimage工具包（scikit-image），它也是图像处理工具包。用过Matlab的同学知道，Matlab处理起图像来非常方便。skimage可以和它相媲美，集成了很多图像处理函数，其中对不同分类标识显示不同的颜色。在Python中图像处理工具包，我们用的是skimage工具包。</p><p>这节课没有太多的理论概念，主要讲了K-Means聚类工具，数据规范化工具，以及图像处理工具的使用，并在图像分割中进行运用。其中涉及到的工具包比较多，你需要在练习的时候多加体会。当然不同尺寸的图像，K-Means运行的时间也是不同的。如果图像尺寸比较大，你可以事先进行压缩，长宽在200像素内运行速度会比较快，如果超过了1000像素，速度会很慢。</p><p><img src="https://static001.geekbang.org/resource/image/5a/99/5a3f0dfaf5e6aaca1e96f488f8a10999.png" alt=""><br><br> 今天我讲了如何使用K-Means聚类做图像分割，谈谈你使用的体会吧。另外我在<a href="https://github.com/cystanford/kmeans/blob/master/baby.jpg" target="_blank" rel="noopener noreferrer">GitHub</a>上上传了一张baby.jpg的图片，请你编写代码用K-Means聚类方法将它分割成16个部分。</p><p>链接：<a href="https://github.com/cystanford/kmeans/blob/master/baby.jpg" target="_blank" rel="noopener noreferrer">https://github.com/cystanford/kmeans/blob/master/baby.jpg</a></p><p>欢迎在评论区与我分享你的答案，也欢迎点击“请朋友读”，把这篇文章分享给你的朋友或者同事。</p>`,52)]))}const d=a(p,[["render",l]]),m=JSON.parse('{"path":"/posts/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%9845%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E6%A8%A1%E5%9D%97%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E7%AF%87/27%E4%B8%A8K-Means%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8K-Means%E5%AF%B9%E5%9B%BE%E5%83%8F%E8%BF%9B%E8%A1%8C%E5%88%86%E5%89%B2%EF%BC%9F.html","title":"27丨K-Means（下）：如何使用K-Means对图像进行分割？","lang":"zh-CN","frontmatter":{"description":"27丨K-Means（下）：如何使用K-Means对图像进行分割？ 上节课，我讲解了K-Means的原理，并且用K-Means对20支亚洲球队进行了聚类，分成3个梯队。今天我们继续用K-Means进行聚类的实战。聚类的一个常用场景就是对图像进行分割。 图像分割就是利用图像自身的信息，比如颜色、纹理、形状等特征进行划分，将图像分割成不同的区域，划分出来的...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/interview/posts/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%9845%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E6%A8%A1%E5%9D%97%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E7%AF%87/27%E4%B8%A8K-Means%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8K-Means%E5%AF%B9%E5%9B%BE%E5%83%8F%E8%BF%9B%E8%A1%8C%E5%88%86%E5%89%B2%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"27丨K-Means（下）：如何使用K-Means对图像进行分割？"}],["meta",{"property":"og:description","content":"27丨K-Means（下）：如何使用K-Means对图像进行分割？ 上节课，我讲解了K-Means的原理，并且用K-Means对20支亚洲球队进行了聚类，分成3个梯队。今天我们继续用K-Means进行聚类的实战。聚类的一个常用场景就是对图像进行分割。 图像分割就是利用图像自身的信息，比如颜色、纹理、形状等特征进行划分，将图像分割成不同的区域，划分出来的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-16T11:19:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-16T11:19:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"27丨K-Means（下）：如何使用K-Means对图像进行分割？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-16T11:19:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755343178000,"updatedTime":1755343178000,"contributors":[{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":1,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":10.34,"words":3103},"filePathRelative":"posts/数据分析实战45讲/第二模块：数据分析算法篇/27丨K-Means（下）：如何使用K-Means对图像进行分割？.md","localizedDate":"2025年8月16日","excerpt":"\\n<p><audio id=\\"audio\\" title=\\"27丨K-Means（下）：如何使用K-Means对图像进行分割？\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/68/32/68974aaf0975c8e01c9dab7897c2a732.mp3\\"></audio></p>\\n<p>上节课，我讲解了K-Means的原理，并且用K-Means对20支亚洲球队进行了聚类，分成3个梯队。今天我们继续用K-Means进行聚类的实战。聚类的一个常用场景就是对图像进行分割。</p>","autoDesc":true}');export{d as comp,m as data};
