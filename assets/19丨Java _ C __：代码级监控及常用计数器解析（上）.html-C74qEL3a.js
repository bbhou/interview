import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a as n,o as i}from"./app-d8EKP-K0.js";const p={};function l(t,a){return i(),e("div",null,a[0]||(a[0]=[n(`<h1 id="_19丨java-c-代码级监控及常用计数器解析-上" tabindex="-1"><a class="header-anchor" href="#_19丨java-c-代码级监控及常用计数器解析-上"><span>19丨Java &amp; C ++：代码级监控及常用计数器解析（上）</span></a></h1><p><audio id="audio" title="19丨Java &amp; C ++：代码级监控及常用计数器解析（上）" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/ca/0e/caf8262ffe95731d5f4fef1f05ca2d0e.mp3"></audio></p><p>在性能测试分析中，有一部分人存在着一个思路上的误解，那就是一开始就一头扎进代码里，折腾代码性能。这是我非常反对的一种做法。</p><p>事实上，要想这么做，有一个前提，那就是架构中的其他组件都经过了千锤百炼，出现问题的可能性极低。</p><p>实际上，我凭着十几年的经验来看，大部分时候，代码出现严重性能瓶颈的情况还真是不多。再加上现在成熟的框架那么多，程序员们很多情况下只写业务实现。在这种情况下，代码出现性能瓶颈的可能性就更低了。</p><p>但我们今天终归要说代码级的监控及常用的计数器。如何去评估一个业务系统的代码性能呢？在我看来，分析的思路是下面这个样子的。</p><img src="https://static001.geekbang.org/resource/image/ee/e3/eebce7bd7cab91685baf4a9a526be9e3.jpg" alt=""><p>从上图可以看到，分析的时候有两个关键点：执行时间和执行空间。我相信很多人都清楚，我们要很快找到执行时间耗在哪一段和空间耗在哪里。</p><p>现在我们来实际操作一下，看如何判断。</p><h2 id="java类应用查找方法执行时间" tabindex="-1"><a class="header-anchor" href="#java类应用查找方法执行时间"><span>Java类应用查找方法执行时间</span></a></h2><p>首先你得选择一个合适的监控工具。Java方法类的监控工具有很多，这里我选择JDK里自带的jvisualvm。</p><p>顺便说一下，我的Java版本号是这个：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>(base) GaoLouMac:~ Zee$ java -version</span></span>
<span class="line"><span>java version &amp;quot;1.8.0_111&amp;quot;</span></span>
<span class="line"><span>Java(TM) SE Runtime Environment (build 1.8.0_111-b14)</span></span>
<span class="line"><span>Java HotSpot(TM) 64-Bit Server VM (build 25.111-b14, mixed mode)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>打开应用服务器上的JMX之后，连上jvisualvm，你会看到这样的视图。</p><img src="https://static001.geekbang.org/resource/image/76/36/76e17407985e427e832c0de988cc8f36.png" alt=""><p>这里再啰嗦一下我们的目标，这时我们要找到消耗CPU的方法，所以要先点<code>Sampler - CPU</code>，你可以看到如下视图。</p><img src="https://static001.geekbang.org/resource/image/d3/63/d3a21195b1b8bcb1838df3d7ec76ef63.png" alt=""><p>从上图可以看到方法执行的累积时间，分别为自用时间百分比、自用时间、自用时间中消耗CPU的时间、总时间、总时间中消耗CPU的时间、样本数。</p><p>从这些数据中就可以看到方法的执行效率了。</p><p>但是，这里面Method这么多，我怎么知道哪个跟我的方法执行时间有关呢？比如说上面这个应用中，最消耗CPU的是JDBC的一个方法fill。这合理吗？</p><p>先来看一下我的脚本。</p><img src="https://static001.geekbang.org/resource/image/ad/b8/ad1e7b5f712dcbb7e7b35af084f01db8.png" alt=""><p>从结构上你就能看出来，我做了登录，然后就做了创建的动作，接着就退出了。</p><p>这几个操作和数据库都有交互。拿create这个步骤来说，它的脚本非常直接，就是一个POST接口。</p><img src="https://static001.geekbang.org/resource/image/7d/dd/7dadcb5071e391a7c97f9ae91e00c9dd.png" alt=""><p>还记得前面我们怎么说查看后端的运行逻辑的吗？后端接收这个POST的代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    @RequestMapping(&amp;quot;/save&amp;quot;)</span></span>
<span class="line"><span>    @ResponseBody</span></span>
<span class="line"><span>    public Object save(Blog blog, HttpSession session){</span></span>
<span class="line"><span>        try{</span></span>
<span class="line"><span>            Long id = blog.getId();</span></span>
<span class="line"><span>            if(id==null){</span></span>
<span class="line"><span>                User user = (User)session.getAttribute(&amp;quot;user&amp;quot;);</span></span>
<span class="line"><span>                blog.setAuthor(user.getName());</span></span>
<span class="line"><span>                blog.setUserId(user.getId());</span></span>
<span class="line"><span>                blog.setCreateTime(new Date());</span></span>
<span class="line"><span>                blog.setLastModifyTime(new Date());</span></span>
<span class="line"><span>                blogWriteService.create(blog);</span></span>
<span class="line"><span>            }else {</span></span>
<span class="line"><span>                blog.setLastModifyTime(new Date());</span></span>
<span class="line"><span>                blogWriteService.update(blog);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }catch (Exception e){</span></span>
<span class="line"><span>            throw new JsonResponseException(e.getMessage());</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        return true;</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的功能就是讲前端内容接收过来放到实体中，然后通过create方法写到数据库中。那么create是怎么实现的呢？</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>    public void  create(Blog blog) {</span></span>
<span class="line"><span>        mapper.insert(blog);</span></span>
<span class="line"><span>        BlogStatistics blogStatistics = new BlogStatistics(blog.getId());</span></span>
<span class="line"><span>        blogStatisticsMapper.insert(blogStatistics);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它就是一个mapper.insert，显然这个create是我们自己实现的代码，里面其实没有什么逻辑。而ReadAheadInputStream.fill是create中的MyBatis调用的JDBC中的方法。 从压力工具到数据库的调用逻辑就是：</p><img src="https://static001.geekbang.org/resource/image/e2/a6/e23bec9dd1d7712ff541c86479433ba6.jpg" alt=""><p>而我们看到的最耗时的方法是最后一个，也就是fill。实际上，我们应该关心的是save接口到底怎么样。我们来过滤下看看。</p><img src="https://static001.geekbang.org/resource/image/53/af/535a53ffb59aa005830e5f30159c2faf.png" alt=""><p>从save的结果上来看，它本身并没有耗什么时间，都是后面的调用在消耗时间。</p><p>我们再来看看cerate。</p><img src="https://static001.geekbang.org/resource/image/36/b6/36e52d8b3f346aa6b66ece606aa6e6b6.png" alt=""><p>它本身也没消耗什么时间。</p><p>顺着逻辑图，我们再接着看MyBatis中的insert方法。</p><img src="https://static001.geekbang.org/resource/image/c7/8a/c780aa816eb132eea8acc0bb06cc0e8a.png" alt=""><p>就这样一层层找下去，最后肯定就找到了fill这个方法了。但是你怎么知道整个调用逻辑中有哪些层级呢？你说我可以看源码。当然不是不可以。但要是没有源码呢？做性能分析的人经常没有源码呀。</p><p>这个时候，我们就要来看栈了。这里我打印了一个调用栈，我们来看下这个逻辑。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&amp;quot;http-nio-8080-exec-1&amp;quot; - Thread t@42</span></span>
<span class="line"><span>   java.lang.Thread.State: RUNNABLE</span></span>
<span class="line"><span>	...............</span></span>
<span class="line"><span>	at com.mysql.jdbc.util.ReadAheadInputStream.fill(ReadAheadInputStream.java:100)</span></span>
<span class="line"><span>    ...............</span></span>
<span class="line"><span>    ...............</span></span>
<span class="line"><span>    at com.sun.proxy.$Proxy87.create(Unknown Source)</span></span>
<span class="line"><span>	...............</span></span>
<span class="line"><span>	at com.blog.controller.BackBlogController.save(BackBlogController.java:85)</span></span>
<span class="line"><span>	...............</span></span>
<span class="line"><span>	at java.lang.Thread.run(Thread.java:745)</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>   Locked ownable synchronizers:</span></span>
<span class="line"><span>	- locked &amp;lt;4b6968c3&amp;gt; (a java.util.concurrent.ThreadPoolExecutor$Worker)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我把其他的都给清掉了，我们只看最简单的栈逻辑，其中UnknownSource的部分是因为反射实现的insert没有把源码反编译出来。</p><p>其实这个栈有117行，我怕你看晕。</p><p>从这一层一层的关系中，我们就可以知道调用逻辑了。知道调用逻辑的方法有很多，看源码也行，看编译后运行的代码也行，关键在于知道谁调了谁，这样就行了。</p><p>我这个还算是清晰的调用逻辑，要是代码调用关系再复杂一些，分分钟有想死有没有？</p><p>不过比较好的是，像jvisualvm这样的工具给我们提供了很多便利。这时可能有人会跳起来了，为什么不用Arthas、BTrace之类的工具呢？如果你喜欢的话，可以把Athas弄上，像下面这样。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[arthas@1]$ trace com.blog.controller.BackBlogController save</span></span>
<span class="line"><span>Press Q or Ctrl+C to abort.</span></span>
<span class="line"><span>Affect(class-cnt:2 , method-cnt:2) cost in 320 ms.</span></span>
<span class="line"><span>\`---ts=2020-01-06 10:38:37;thread_name=http-nio-8080-exec-2;id=2b;is_daemon=true;priority=5;TCCL=org.apache.catalina.loader.ParallelWebappClassLoader@4f2895f8</span></span>
<span class="line"><span>    \`---[29.048684ms] com.blog.controller.BackBlogController$$EnhancerBySpringCGLIB$$586fe45c:save()</span></span>
<span class="line"><span>        \`---[28.914387ms] org.springframework.cglib.proxy.MethodInterceptor:intercept() #0</span></span>
<span class="line"><span>            \`---[27.897315ms] com.blog.controller.BackBlogController:save()</span></span>
<span class="line"><span>                ...............</span></span>
<span class="line"><span>                \`---[24.192784ms] com.blog.service.BlogWriteService:create() #85</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这也能看出来creat是消耗了时间的。如果你接着跟踪create方法。如下所示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[arthas@1]$ trace com.blog.service.BlogWriteService create //这一行是arthas中跟踪class中的某个具体方法的语句。</span></span>
<span class="line"><span>Press Q or Ctrl+C to abort.</span></span>
<span class="line"><span>Affect(class-cnt:2 , method-cnt:2) cost in 199 ms. //被跟踪方法的处理次数和时长</span></span>
<span class="line"><span>\`---ts=2020-01-06 10:41:51;thread_name=http-nio-8080-exec-4;id=2f;is_daemon=true;priority=5;TCCL=org.apache.catalina.loader.ParallelWebappClassLoader@4f2895f8</span></span>
<span class="line"><span>    \`---[6.939189ms] com.sun.proxy.$Proxy87:create()</span></span>
<span class="line"><span>\`---ts=2020-01-06 10:41:51;thread_name=http-nio-8080-exec-10;id=38;is_daemon=true;priority=5;TCCL=org.apache.catalina.loader.ParallelWebappClassLoader@4f2895f8</span></span>
<span class="line"><span>        \`---[4.144799ms] com.blog.service.BlogWriteServiceImpl:create()  //写接口中create方法耗时</span></span>
<span class="line"><span>            +---[2.131934ms] tk.mybatis.mapper.common.Mapper:insert() #24   //mybatis中insert方法耗时</span></span>
<span class="line"><span>                ...............</span></span>
<span class="line"><span>            \`---[1.95441ms] com.blog.mapper.BlogStatisticsMapper:insert() #26 //insert方法调用了上面的create方法耗时</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要是接着往下跟踪，就可以看到反射这一块了。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[arthas@1]$ trace tk.mybatis.mapper.common.Mapper insert</span></span>
<span class="line"><span>Press Q or Ctrl+C to abort.</span></span>
<span class="line"><span>Affect(class-cnt:5 , method-cnt:5) cost in 397 ms.</span></span>
<span class="line"><span>\`---ts=2020-01-06 10:44:01;thread_name=http-nio-8080-exec-5;id=33;is_daemon=true;priority=5;TCCL=org.apache.catalina.loader.ParallelWebappClassLoader@4f2895f8</span></span>
<span class="line"><span>    \`---[3.800107ms] com.sun.proxy.$Proxy80:insert()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>类似的，你还可以玩JDK自带的工具jdb，它也可以直接attach到一个进程上，调试能力也是不弱的。</p><p>在我看来，这些工具、手段都是为了实现从<code>响应时间长&amp;lt;-&amp;gt;代码行</code>的分析过程。思路是最重要的。</p><p>另外也要说一下，现在有的APM工具也可以实现这样的功能，但是呢，我并不建议一开始就上这么细致的工具，因为不管APM产品吹得有多牛逼，它都是要消耗10%左右的CPU的。并且，你觉得直接在生产上装一个APM工具的agent到业务系统中是合理的吗？如果是自己实现的metrics方法，输出性能数据尚可接受，如果是别人的这类工具，还是算了。</p><p>在大部分时候，我都不建议在生产上用APM工具。万一生产上真的有极端的情况，需要看细致的性能问题，再临时attach上去，也可以做到。何必为了可能出现的问题而长时间地消耗资源呢。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>大部分时间里，性能测试和分析都在和时间打交道，而在时间的拆分逻辑中，我们在前面也提到过思路，如何一步步把时间拆解到应用当中，那就是<strong>分段</strong>。</p><p>当拆解到应用当中之后，就是抓函数方法的执行时间了。这是保证我们从前到后分析逻辑的关键一环，请你注意，是关键一环，而不是最初的一环。</p><p>通过这篇文章我想告诉你，在大部分的开发语言中，都有手段直接将方法的执行时间消耗抓出来，你可能现在还不知道是什么方法，没关系，因为跟踪的手段有很多，你可以临时去学习如何操作。</p><p>我只要在你的脑子里种下这样的一种印象，那就是，有办法抓到函数方法的执行时间消耗在哪里！</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题"><span>思考题</span></a></h2><p>最后给你留两道思考题吧。我为什么不建议在生产环境中一开始就上APM类工具来抓取方法的执行时间呢？你有什么方法可以抓取到Java语言中的方法执行时间？如果你擅长其他语言，也可以描述其他语言中的方法执行时间抓取工具。</p><p>欢迎你在评论区写下你的思考，也欢迎把这篇文章分享给你的朋友或者同事，一起交流一下。</p>`,64)]))}const d=s(p,[["render",l]]),o=JSON.parse('{"path":"/posts/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%9830%E8%AE%B2/%E7%AC%AC%E4%B8%89%E6%A8%A1%E5%9D%97%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%AF%87/19%E4%B8%A8Java%20_%20C%20__%EF%BC%9A%E4%BB%A3%E7%A0%81%E7%BA%A7%E7%9B%91%E6%8E%A7%E5%8F%8A%E5%B8%B8%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89.html","title":"19丨Java & C ++：代码级监控及常用计数器解析（上）","lang":"zh-CN","frontmatter":{"description":"19丨Java & C ++：代码级监控及常用计数器解析（上） 在性能测试分析中，有一部分人存在着一个思路上的误解，那就是一开始就一头扎进代码里，折腾代码性能。这是我非常反对的一种做法。 事实上，要想这么做，有一个前提，那就是架构中的其他组件都经过了千锤百炼，出现问题的可能性极低。 实际上，我凭着十几年的经验来看，大部分时候，代码出现严重性能瓶颈的情况...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/interview/posts/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%9830%E8%AE%B2/%E7%AC%AC%E4%B8%89%E6%A8%A1%E5%9D%97%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%AF%87/19%E4%B8%A8Java%20_%20C%20__%EF%BC%9A%E4%BB%A3%E7%A0%81%E7%BA%A7%E7%9B%91%E6%8E%A7%E5%8F%8A%E5%B8%B8%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"19丨Java & C ++：代码级监控及常用计数器解析（上）"}],["meta",{"property":"og:description","content":"19丨Java & C ++：代码级监控及常用计数器解析（上） 在性能测试分析中，有一部分人存在着一个思路上的误解，那就是一开始就一头扎进代码里，折腾代码性能。这是我非常反对的一种做法。 事实上，要想这么做，有一个前提，那就是架构中的其他组件都经过了千锤百炼，出现问题的可能性极低。 实际上，我凭着十几年的经验来看，大部分时候，代码出现严重性能瓶颈的情况..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-16T11:19:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-16T11:19:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"19丨Java & C ++：代码级监控及常用计数器解析（上）\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-16T11:19:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755343178000,"updatedTime":1755343178000,"contributors":[{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":1,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":8.14,"words":2442},"filePathRelative":"posts/性能测试实战30讲/第三模块：性能监控分析工具篇/19丨Java & C ++：代码级监控及常用计数器解析（上）.md","localizedDate":"2025年8月16日","excerpt":"\\n<p><audio id=\\"audio\\" title=\\"19丨Java &amp; C ++：代码级监控及常用计数器解析（上）\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/ca/0e/caf8262ffe95731d5f4fef1f05ca2d0e.mp3\\"></audio></p>\\n<p>在性能测试分析中，有一部分人存在着一个思路上的误解，那就是一开始就一头扎进代码里，折腾代码性能。这是我非常反对的一种做法。</p>\\n<p>事实上，要想这么做，有一个前提，那就是架构中的其他组件都经过了千锤百炼，出现问题的可能性极低。</p>","autoDesc":true}');export{d as comp,o as data};
