import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as i}from"./app-d8EKP-K0.js";const p={};function t(r,e){return i(),a("div",null,e[0]||(e[0]=[n(`<h1 id="_03-快属性和慢属性-v8是怎样提升对象属性访问速度的" tabindex="-1"><a class="header-anchor" href="#_03-快属性和慢属性-v8是怎样提升对象属性访问速度的"><span>03 _ 快属性和慢属性：V8是怎样提升对象属性访问速度的？</span></a></h1><p><audio id="audio" title="03 | 快属性和慢属性：V8是怎样提升对象属性访问速度的？" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/fb/bb/fb3e7b801528c255e041f54249c75cbb.mp3"></audio></p><p>你好，我是李兵。</p><p>在前面的课程中，我们介绍了JavaScript中的对象是由一组组属性和值的集合，从JavaScript语言的角度来看，JavaScript对象像一个字典，字符串作为键名，任意对象可以作为键值，可以通过键名读写键值。</p><p>然而在V8实现对象存储时，并没有完全采用字典的存储方式，这主要是出于性能的考量。因为字典是非线性的数据结构，查询效率会低于线性的数据结构，V8为了提升存储和查找效率，采用了一套复杂的存储策略。</p><img src="https://static001.geekbang.org/resource/image/c9/ef/c970cdc7b89bfe0a12e560fe94fcdfef.jpg" alt="" title="线性结构和非线性结构"><p>今天这节课我们就来分析下V8采用了哪些策略提升了对象属性的访问速度。</p><h2 id="常规属性-properties-和排序属性-element" tabindex="-1"><a class="header-anchor" href="#常规属性-properties-和排序属性-element"><span>常规属性(properties)和排序属性(element)</span></a></h2><p>在开始之前，我们先来了解什么是对象中的<strong>常规属性</strong>和<strong>排序属性</strong>，你可以先参考下面这样一段代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>function Foo() {</span></span>
<span class="line"><span>    this[100] = &#39;test-100&#39;</span></span>
<span class="line"><span>    this[1] = &#39;test-1&#39;</span></span>
<span class="line"><span>    this[&amp;quot;B&amp;quot;] = &#39;bar-B&#39;</span></span>
<span class="line"><span>    this[50] = &#39;test-50&#39;</span></span>
<span class="line"><span>    this[9] =  &#39;test-9&#39;</span></span>
<span class="line"><span>    this[8] = &#39;test-8&#39;</span></span>
<span class="line"><span>    this[3] = &#39;test-3&#39;</span></span>
<span class="line"><span>    this[5] = &#39;test-5&#39;</span></span>
<span class="line"><span>    this[&amp;quot;A&amp;quot;] = &#39;bar-A&#39;</span></span>
<span class="line"><span>    this[&amp;quot;C&amp;quot;] = &#39;bar-C&#39;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>var bar = new Foo()</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>for(key in bar){</span></span>
<span class="line"><span>    console.log(\`index:\${key}  value:\${bar[key]}\`)</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面这段代码中，我们利用构造函数Foo创建了一个bar对象，在构造函数中，我们给bar对象设置了很多属性，包括了数字属性和字符串属性，然后我们枚举出来了bar对象中所有的属性，并将其一一打印出来，下面就是执行这段代码所打印出来的结果：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>index:1  value:test-1</span></span>
<span class="line"><span>index:3  value:test-3</span></span>
<span class="line"><span>index:5  value:test-5</span></span>
<span class="line"><span>index:8  value:test-8</span></span>
<span class="line"><span>index:9  value:test-9</span></span>
<span class="line"><span>index:50  value:test-50</span></span>
<span class="line"><span>index:100  value:test-100</span></span>
<span class="line"><span>index:B  value:bar-B</span></span>
<span class="line"><span>index:A  value:bar-A</span></span>
<span class="line"><span>index:C  value:bar-C</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>观察这段打印出来的数据，我们发现打印出来的属性顺序并不是我们设置的顺序，我们设置属性的时候是乱序设置的，比如开始先设置100，然后又设置了1，但是输出的内容却非常规律，总的来说体现在以下两点：</p><ul><li>设置的数字属性被最先打印出来了，并且是按照数字大小的顺序打印的；</li><li>设置的字符串属性依然是按照之前的设置顺序打印的，比如我们是按照B、A、C的顺序设置的，打印出来依然是这个顺序。</li></ul><p>之所以出现这样的结果，是因为在ECMAScript规范中定义了<strong>数字属性应该按照索引值大小升序排列，字符串属性根据创建时的顺序升序排列。</strong></p><p>在这里我们把对象中的数字属性称为<strong>排序属性</strong>，在V8中被称为<strong>elements</strong>，字符串属性就被称为<strong>常规属性</strong>，在V8中被称为<strong>properties</strong>。</p><p>在V8内部，为了有效地提升存储和访问这两种属性的性能，分别使用了两个<strong>线性数据结构</strong>来分别保存排序属性和常规属性，具体结构如下图所示：</p><img src="https://static001.geekbang.org/resource/image/af/75/af2654db3d3a2e0b9a9eaa25e862cc75.jpg" alt="" title="V8内部的对象构造"><p>通过上图我们可以发现，bar对象包含了两个隐藏属性：elements属性和properties属性，elements属性指向了elements对象，在elements对象中，会按照顺序存放排序属性，properties属性则指向了properties对象，在properties对象中，会按照创建时的顺序保存了常规属性。</p><p>分解成这两种线性数据结构之后，如果执行索引操作，那么V8会先从elements属性中按照顺序读取所有的元素，然后再在properties属性中读取所有的元素，这样就完成一次索引操作。</p><h2 id="快属性和慢属性" tabindex="-1"><a class="header-anchor" href="#快属性和慢属性"><span>快属性和慢属性</span></a></h2><p>将不同的属性分别保存到elements属性和properties属性中，无疑简化了程序的复杂度，但是在查找元素时，却多了一步操作，比如执行 <code>bar.B</code>这个语句来查找B的属性值，那么在V8会先查找出properties属性所指向的对象properties，然后再在properties对象中查找B属性，这种方式在查找过程中增加了一步操作，因此会影响到元素的查找效率。</p><p>基于这个原因，V8采取了一个权衡的策略以加快查找属性的效率，这个策略是将部分常规属性直接存储到对象本身，我们把这称为**对象内属性(in-object properties)。**对象在内存中的展现形式你可以参看下图：</p><img src="https://static001.geekbang.org/resource/image/f1/3e/f12b4c6f6e631ce51d5b4f288dbfb13e.jpg" alt="" title="对象内属性"><p>采用对象内属性之后，常规属性就被保存到bar对象本身了，这样当再次使用<code>bar.B</code>来查找B的属性值时，V8就可以直接从bar对象本身去获取该值就可以了，这种方式减少查找属性值的步骤，增加了查找效率。</p><p>不过对象内属性的数量是固定的，默认是10个，如果添加的属性超出了对象分配的空间，则它们将被保存在常规属性存储中。虽然属性存储多了一层间接层，但可以自由地扩容。</p><p>通常，我们将保存在线性数据结构中的属性称之为“快属性”，因为线性数据结构中只需要通过索引即可以访问到属性，虽然访问线性结构的速度快，但是如果从线性结构中添加或者删除大量的属性时，则执行效率会非常低，这主要因为会产生大量时间和内存开销。</p><p>因此，如果一个对象的属性过多时，V8就会采取另外一种存储策略，那就是“慢属性”策略，但慢属性的对象内部会有独立的非线性数据结构(词典)作为属性存储容器。所有的属性元信息不再是线性存储的，而是直接保存在属性字典中。</p><img src="https://static001.geekbang.org/resource/image/e8/17/e8ce990dce53295a414ce79e38149917.jpg" alt="" title="慢属性是如何存储的"><h2 id="实践-在chrome中查看对象布局" tabindex="-1"><a class="header-anchor" href="#实践-在chrome中查看对象布局"><span>实践：在Chrome中查看对象布局</span></a></h2><p>现在我们知道了V8是怎么存储对象的了，接下来我们来结合Chrome中的内存快照，来看看对象在内存中是如何布局的？</p><p>你可以打开Chrome开发者工具，先选择控制台标签，然后在控制台中执行以下代码查看内存快照：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>function Foo(property_num,element_num) {</span></span>
<span class="line"><span>    //添加可索引属性</span></span>
<span class="line"><span>    for (let i = 0; i &amp;lt; element_num; i++) {</span></span>
<span class="line"><span>        this[i] = \`element\${i}\`</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    //添加常规属性</span></span>
<span class="line"><span>    for (let i = 0; i &amp;lt; property_num; i++) {</span></span>
<span class="line"><span>        let ppt = \`property\${i}\`</span></span>
<span class="line"><span>        this[ppt] = ppt</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>var bar = new Foo(10,10)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面我们创建了一个构造函数，可以利用该构造函数创建了新的对象，我给该构造函数设置了两个参数property_num、element_num，分别代表创建常规属性的个数和排序属性的个数，我们先将这两种类型的个数都设置为10个，然后利用该构造函数创建了一个新的bar对象。</p><p>创建了函数对象，接下来我们就来看看构造函数和对象在内存中的状态。你可以将Chrome开发者工具切换到Memory标签，然后点击左侧的小圆圈就可以捕获当前的内存快照，最终截图如下所示：</p><img src="https://static001.geekbang.org/resource/image/d2/d3/d2a123d127a2895d9f0d09be61cc55d3.png" alt="" title="V8内存快照截图"><p>上图就是收集了当前内存快照的界面，要想查找我们刚才创建的对象，你可以在搜索框里面输入构造函数Foo，Chrome会列出所有经过构造函数Foo创建的对象，如下图所示：</p><img src="https://static001.geekbang.org/resource/image/2b/89/2b4ee447d061f72026ca38d6dfc25389.png" alt="" title="从内存快照搜索构造函数"><p>观察上图，我们搜索出来了所有经过构造函数Foo创建的对象，点开Foo的那个下拉列表，第一个就是刚才创建的bar对象，我们可以看到bar对象有一个elements属性，这里面就包含我们创造的所有的排序属性，那么怎么没有常规属性对象呢？</p><p>这是因为只创建了10个常规属性，所以V8将这些常规属性直接做成了bar对象的对象内属性。</p><p>所以这时候的数据内存布局是这样的：</p><ul><li>10个常规属性作为对象内属性，存放在bar函数内部；</li><li>10个排序属性存放在elements中。</li></ul><p>接下来我们可以将创建的对象属性的个数调整到20个，你可以在控制台执行下面这段代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>var bar2 = new Foo(20,10)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>然后我们再重新生成内存快照，再来看看生成的图片：</p><img src="https://static001.geekbang.org/resource/image/ef/6e/ef117bbc99504f1daea52a0831a5756e.png" alt="" title=" 利用构造函数生成的对象"><p>我们可以看到，构造函数Foo下面已经有了两个对象了，其中一个bar，另外一个是bar2，我们点开第一个bar2对象，内容如下所示：</p><img src="https://static001.geekbang.org/resource/image/49/86/49c1f8e735e5b7772f3d54fb53eae386.png" alt="" title="查看对象属性"><p>由于创建的常用属性超过了10个，所以另外10个常用属性就被保存到properties中了，注意因为properties中只有10个属性，所以依然是线性的数据结构，我们可以看其都是按照创建时的顺序来排列的。</p><p>所以这时候属性的内存布局是这样的：</p><ul><li>10属性直接存放在bar2的对象内;</li><li>10个常规属性以线性数据结构的方式存放在properties属性里面;</li><li>10个数字属性存放在elements属性里面。</li></ul><p>如果常用属性太多了，比如创建了100个，那么我们再来看看其内存分布，你可以执行下面这段代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>var bar3 = new Foo(100,10)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>然后以同样的方式打开bar3，查看其内存布局，最终如下图所示：</p><img src="https://static001.geekbang.org/resource/image/da/69/dab6d6e2291117781e4294f27113d469.png" alt="" title="利用字典存放常规元素"><p>结合上图，我们可以看到，这时候的properties属性里面的数据并不是线性存储的，而是以非线性的字典形式存储的，所以这时候属性的内存布局是这样的：</p><ul><li>10属性直接存放在bar3的对象内;</li><li>90个常规属性以非线性字典的这种数据结构方式存放在properties属性里面;</li><li>10个数字属性存放在elements属性里面。</li></ul><h2 id="其他属性" tabindex="-1"><a class="header-anchor" href="#其他属性"><span>其他属性</span></a></h2><p>好了，现在我们知道V8是怎么存储对象的了，不过这里还有几个重要的隐藏属性我还没有介绍，下面我们就来简单地看下。你可以先看下图：</p><img src="https://static001.geekbang.org/resource/image/82/4d/82463f4c1a4bf5fb8920b0099284e84d.png" alt="" title="其他隐藏属性"><p>观察上图，除了elements和properties属性，V8还为每个对象实现了map属性和__proto__属性。__proto__属性就是原型，是用来实现JavaScript继承的，我们会在下一节来介绍；而map则是隐藏类，我们会在《<a href="https://time.geekbang.org/column/article/226417" target="_blank" rel="noopener noreferrer">15 | 隐藏类：如何在内存中快速查找对象属性？</a>》这一节中介绍其工作机制。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>好了，本节的内容就介绍到这里，下面我来总结下本文的主要内容：</p><p>本文我们的主要目标是介绍V8内部是如何存储对象的，因为JavaScript中的对象是由一组组属性和值组成的，所以最简单的方式是使用一个字典来保存属性和值，但是由于字典是非线性结构，所以如果使用字典，读取效率会大大降低。</p><p>为了提升查找效率，V8在对象中添加了两个隐藏属性，排序属性和常规属性，element属性指向了elements对象，在elements对象中，会按照顺序存放排序属性。properties属性则指向了properties对象，在properties对象中，会按照创建时的顺序保存常规属性。</p><p>通过引入这两个属性，加速了V8查找属性的速度，为了更加进一步提升查找效率，V8还实现了内置内属性的策略，当常规属性少于一定数量时，V8就会将这些常规属性直接写进对象中，这样又节省了一个中间步骤。</p><p>但是如果对象中的属性过多时，或者存在反复添加或者删除属性的操作，那么V8就会将线性的存储模式降级为非线性的字典存储模式，这样虽然降低了查找速度，但是却提升了修改对象的属性的速度。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题"><span>思考题</span></a></h2><p>通常，我们不建议使用delete来删除属性，你能结合文中介绍的快属性和慢属性，给出不建议使用delete的原因吗？欢迎你在留言区与我分享讨论。</p><p>感谢你的阅读，如果你觉得这一讲的内容对你有所启发，也欢迎把它分享给你的朋友。</p>`,70)]))}const o=s(p,[["render",t]]),d=JSON.parse('{"path":"/posts/%E5%9B%BE%E8%A7%A3%20Google%20V8/JavaScript%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E7%AF%87/03%20_%20%E5%BF%AB%E5%B1%9E%E6%80%A7%E5%92%8C%E6%85%A2%E5%B1%9E%E6%80%A7%EF%BC%9AV8%E6%98%AF%E6%80%8E%E6%A0%B7%E6%8F%90%E5%8D%87%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6%E7%9A%84%EF%BC%9F.html","title":"03 _ 快属性和慢属性：V8是怎样提升对象属性访问速度的？","lang":"zh-CN","frontmatter":{"description":"03 _ 快属性和慢属性：V8是怎样提升对象属性访问速度的？ 你好，我是李兵。 在前面的课程中，我们介绍了JavaScript中的对象是由一组组属性和值的集合，从JavaScript语言的角度来看，JavaScript对象像一个字典，字符串作为键名，任意对象可以作为键值，可以通过键名读写键值。 然而在V8实现对象存储时，并没有完全采用字典的存储方式，这...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/interview/posts/%E5%9B%BE%E8%A7%A3%20Google%20V8/JavaScript%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E7%AF%87/03%20_%20%E5%BF%AB%E5%B1%9E%E6%80%A7%E5%92%8C%E6%85%A2%E5%B1%9E%E6%80%A7%EF%BC%9AV8%E6%98%AF%E6%80%8E%E6%A0%B7%E6%8F%90%E5%8D%87%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6%E7%9A%84%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"03 _ 快属性和慢属性：V8是怎样提升对象属性访问速度的？"}],["meta",{"property":"og:description","content":"03 _ 快属性和慢属性：V8是怎样提升对象属性访问速度的？ 你好，我是李兵。 在前面的课程中，我们介绍了JavaScript中的对象是由一组组属性和值的集合，从JavaScript语言的角度来看，JavaScript对象像一个字典，字符串作为键名，任意对象可以作为键值，可以通过键名读写键值。 然而在V8实现对象存储时，并没有完全采用字典的存储方式，这..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-16T11:19:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-16T11:19:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"03 _ 快属性和慢属性：V8是怎样提升对象属性访问速度的？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-16T11:19:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755343178000,"updatedTime":1755343178000,"contributors":[{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":1,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":11.23,"words":3368},"filePathRelative":"posts/图解 Google V8/JavaScript设计思想篇/03 _ 快属性和慢属性：V8是怎样提升对象属性访问速度的？.md","localizedDate":"2025年8月16日","excerpt":"\\n<p><audio id=\\"audio\\" title=\\"03 | 快属性和慢属性：V8是怎样提升对象属性访问速度的？\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/fb/bb/fb3e7b801528c255e041f54249c75cbb.mp3\\"></audio></p>\\n<p>你好，我是李兵。</p>\\n<p>在前面的课程中，我们介绍了JavaScript中的对象是由一组组属性和值的集合，从JavaScript语言的角度来看，JavaScript对象像一个字典，字符串作为键名，任意对象可以作为键值，可以通过键名读写键值。</p>","autoDesc":true}');export{o as comp,d as data};
