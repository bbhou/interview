import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as e,o as i}from"./app-d8EKP-K0.js";const p={};function l(r,s){return i(),n("div",null,s[0]||(s[0]=[e(`<h1 id="_13丨什么是存储过程-在实际项目中用得多么" tabindex="-1"><a class="header-anchor" href="#_13丨什么是存储过程-在实际项目中用得多么"><span>13丨什么是存储过程，在实际项目中用得多么？</span></a></h1><p><audio id="audio" title="13丨什么是存储过程，在实际项目中用得多么？" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/7a/cb/7af0629b30613af937de2c126ce081cb.mp3"></audio></p><p>上一节我介绍了视图，它是SQL中的一个重要应用，使用视图对SQL查询进行封装，可以让SQL的代码结构更清晰，让用户权限管理更安全。</p><p>今天我来讲一下SQL的存储过程，它是SQL中另一个重要应用，和视图一样，都是对SQL代码进行封装，可以反复利用。它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是虚拟表，通常不对底层数据表直接操作，而存储过程是程序化的SQL，可以直接操作底层数据表，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。存储过程可以说是由SQL语句和流控制语句构成的语句集合，它和我们之前学到的函数一样，可以接收输入参数，也可以返回输出参数给调用者，返回计算结果。</p><p>今天有关存储过程的内容，你将重点掌握以下几个部分：</p><ol><li>什么是存储过程，如何创建一个存储过程？</li><li>流控制语句都有哪些，如何使用它们？</li><li>各大公司是如何看待存储过程的？在实际工作中，我们该如何使用存储过程？</li></ol><h2 id="什么是存储过程-如何创建一个存储过程" tabindex="-1"><a class="header-anchor" href="#什么是存储过程-如何创建一个存储过程"><span>什么是存储过程，如何创建一个存储过程</span></a></h2><p>存储过程的英文是Stored Procedure。它的思想很简单，就是SQL语句的封装。一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。我在前面讲过，存储过程实际上由SQL语句和流控制语句共同组成。流控制语句都有哪些呢？这个我稍后讲解。</p><p>我们先来看下如何定义一个存储过程：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>CREATE PROCEDURE 存储过程名称([参数列表])</span></span>
<span class="line"><span>BEGIN</span></span>
<span class="line"><span>    需要执行的语句</span></span>
<span class="line"><span>END</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里，我们使用CREATE PROCEDURE创建一个存储过程，后面是存储过程的名称，以及过程所带的参数，可以包括输入参数和输出参数。最后由BEGIN和END来定义我们所要执行的语句块。</p><p>和视图一样，我们可以删除已经创建的存储过程，使用的是DROP PROCEDURE。如果要更新存储过程，我们需要使用ALTER PROCEDURE。</p><p>讲完了如何创建，更新和删除一个存储过程，下面我们来看下如何实现一个简单的存储过程。比如我想做一个累加运算，计算1+2+…+n等于多少，我们可以通过参数n来表示想要累加的个数，那么如何用存储过程实现这一目的呢？这里我做一个add_num的存储过程，具体的代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>CREATE PROCEDURE \`add_num\`(IN n INT)</span></span>
<span class="line"><span>BEGIN</span></span>
<span class="line"><span>       DECLARE i INT;</span></span>
<span class="line"><span>       DECLARE sum INT;</span></span>
<span class="line"><span>       </span></span>
<span class="line"><span>       SET i = 1;</span></span>
<span class="line"><span>       SET sum = 0;</span></span>
<span class="line"><span>       WHILE i &amp;lt;= n DO</span></span>
<span class="line"><span>              SET sum = sum + i;</span></span>
<span class="line"><span>              SET i = i +1;</span></span>
<span class="line"><span>       END WHILE;</span></span>
<span class="line"><span>       SELECT sum;</span></span>
<span class="line"><span>END</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们需要再次使用这个存储过程的时候，直接使用 <code>CALL add_num(50);</code>即可。这里我传入的参数为50，也就是统计1+2+…+50的积累之和，查询结果为：</p><p><img src="https://static001.geekbang.org/resource/image/e4/1e/e4e29b71160980a9208c8da4dc2a6f1e.png" alt=""><br><br> 这就是一个简单的存储过程，除了理解1+2+…+n的实现过程，还有两点你需要理解，一个是DELIMITER定义语句的结束符，另一个是存储过程的三种参数类型。</p><p>我们先来看下DELIMITER的作用。如果你使用Navicat这个工具来管理MySQL执行存储过程，那么直接执行上面这段代码就可以了。如果用的是MySQL，你还需要用DELIMITER来临时定义新的结束符。因为默认情况下SQL采用（；）作为结束符，这样当存储过程中的每一句SQL结束之后，采用（；）作为结束符，就相当于告诉SQL可以执行这一句了。但是存储过程是一个整体，我们不希望SQL逐条执行，而是采用存储过程整段执行的方式，因此我们就需要临时定义新的DELIMITER，新的结束符可以用（//）或者（$$）。如果你用的是MySQL，那么上面这段代码，应该写成下面这样：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>DELIMITER //</span></span>
<span class="line"><span>CREATE PROCEDURE \`add_num\`(IN n INT)</span></span>
<span class="line"><span>BEGIN</span></span>
<span class="line"><span>       DECLARE i INT;</span></span>
<span class="line"><span>       DECLARE sum INT;</span></span>
<span class="line"><span>       </span></span>
<span class="line"><span>       SET i = 1;</span></span>
<span class="line"><span>       SET sum = 0;</span></span>
<span class="line"><span>       WHILE i &amp;lt;= n DO</span></span>
<span class="line"><span>              SET sum = sum + i;</span></span>
<span class="line"><span>              SET i = i +1;</span></span>
<span class="line"><span>       END WHILE;</span></span>
<span class="line"><span>       SELECT sum;</span></span>
<span class="line"><span>END //</span></span>
<span class="line"><span>DELIMITER ;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先我用（//）作为结束符，又在整个存储过程结束后采用了（//）作为结束符号，告诉SQL可以执行了，然后再将结束符还原成默认的（;）。</p><p>需要注意的是，如果你用的是Navicat工具，那么在编写存储过程的时候，Navicat会自动设置DELIMITER为其他符号，我们不需要再进行DELIMITER的操作。</p><p>我们再来看下存储过程的3种参数类型。在刚才的存储过程中，我们使用了IN类型的参数，另外还有OUT类型和INOUT类型，作用如下：</p><p><img src="https://static001.geekbang.org/resource/image/8c/29/8c12ca959dbc6cfe1d62459481454429.png" alt=""><br><br> IN和OUT的结合，既用于存储过程的传入参数，同时又可以把计算结果放到参数中，调用者可以得到返回值。</p><p>你能看到，IN参数必须在调用存储过程时指定，而在存储过程中修改该参数的值不能被返回。而OUT参数和INOUT参数可以在存储过程中被改变，并可返回。</p><p>举个例子，这里会用到我们之前讲过的王者荣耀的英雄数据表heros。假设我想创建一个存储类型get_hero_scores，用来查询某一类型英雄中的最大的最大生命值，最小的最大魔法值，以及平均最大攻击值，那么该怎么写呢？</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>CREATE PROCEDURE \`get_hero_scores\`(</span></span>
<span class="line"><span>       OUT max_max_hp FLOAT,</span></span>
<span class="line"><span>       OUT min_max_mp FLOAT,</span></span>
<span class="line"><span>       OUT avg_max_attack FLOAT,  </span></span>
<span class="line"><span>       s VARCHAR(255)</span></span>
<span class="line"><span>       )</span></span>
<span class="line"><span>BEGIN</span></span>
<span class="line"><span>       SELECT MAX(hp_max), MIN(mp_max), AVG(attack_max) FROM heros WHERE role_main = s INTO max_max_hp, min_max_mp, avg_max_attack;</span></span>
<span class="line"><span>END</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你能看到我定义了4个参数类型，其中3个为OUT类型，分别为max_max_hp、min_max_mp和avg_max_attack，另一个参数s为IN类型。</p><p>这里我们从heros数据表中筛选主要英雄定位为s的英雄数据，即筛选条件为role_main=s，提取这些数据中的最大的最大生命值，最小的最大魔法值，以及平均最大攻击值，分别赋值给变量max_max_hp、min_max_mp和avg_max_attack。</p><p>然后我们就可以调用存储过程，使用下面这段代码即可：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>CALL get_hero_scores(@max_max_hp, @min_max_mp, @avg_max_attack, &#39;战士&#39;);</span></span>
<span class="line"><span>SELECT @max_max_hp, @min_max_mp, @avg_max_attack;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果：</p><img src="https://static001.geekbang.org/resource/image/7f/e9/7f059f3cb9c345530c67db42af5d04e9.png" alt=""><h2 id="流控制语句" tabindex="-1"><a class="header-anchor" href="#流控制语句"><span>流控制语句</span></a></h2><p>流控制语句是用来做流程控制的，我刚才讲了两个简单的存储过程的例子，一个是1+2+…+n的结果计算，一个是王者荣耀的数据查询，你能看到这两个例子中，我用到了下面的流控制语句：</p><ol><li>BEGIN…END：BEGIN…END中间包含了多个语句，每个语句都以（;）号为结束符。</li><li>DECLARE：DECLARE用来声明变量，使用的位置在于BEGIN…END语句中间，而且需要在其他语句使用之前进行变量的声明。</li><li>SET：赋值语句，用于对变量进行赋值。</li><li>SELECT…INTO：把从数据表中查询的结果存放到变量中，也就是为变量赋值。</li></ol><p>除了上面这些用到的流控制语句以外，还有一些常用的流控制语句：</p><p>1.IF…THEN…ENDIF：条件判断语句，我们还可以在IF…THEN…ENDIF中使用ELSE和ELSEIF来进行条件判断。<br><br> 2.CASE：CASE语句用于多条件的分支判断，使用的语法是下面这样的。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>CASE </span></span>
<span class="line"><span>	WHEN expression1 THEN ...</span></span>
<span class="line"><span>	WHEN expression2 THEN ...</span></span>
<span class="line"><span>	...</span></span>
<span class="line"><span>    ELSE </span></span>
<span class="line"><span>    --ELSE语句可以加，也可以不加。加的话代表的所有条件都不满足时采用的方式。</span></span>
<span class="line"><span>END</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3.LOOP、LEAVE和ITERATE：LOOP是循环语句，使用LEAVE可以跳出循环，使用ITERATE则可以进入下一次循环。如果你有面向过程的编程语言的使用经验，你可以把LEAVE理解为BREAK，把ITERATE理解为CONTINUE。<br><br> 4.REPEAT…UNTIL…END REPEAT：这是一个循环语句，首先会执行一次循环，然后在UNTIL中进行表达式的判断，如果满足条件就退出，即END REPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止。<br><br> 5.WHILE…DO…END WHILE：这也是循环语句，和REPEAT循环不同的是，这个语句需要先进行条件判断，如果满足条件就进行循环，如果不满足条件就退出循环。</p><p>我们之前说过SQL是声明型语言，使用SQL就像在使用英语，简单直接。今天讲的存储过程，尤其是在存储过程中使用到的流控制语句，属于过程性语言，类似于C++语言中函数，这些语句可以帮我们解决复杂的业务逻辑。</p><h2 id="关于存储过程使用的争议" tabindex="-1"><a class="header-anchor" href="#关于存储过程使用的争议"><span>关于存储过程使用的争议</span></a></h2><p>尽管存储过程有诸多优点，但是对于存储过程的使用，一直都存在着很多争议，比如有些公司对于大型项目要求使用存储过程，而有些公司在手册中明确禁止使用存储过程，为什么这些公司对存储过程的使用需求差别这么大呢？</p><p>我们得从存储过程的特点来找答案。</p><p>你能看到存储过程有很多好处。</p><p>首先存储过程可以一次编译多次使用。存储过程只在创造时进行编译，之后的使用都不需要重新编译，这就提升了SQL的执行效率。其次它可以减少开发工作量。将代码封装成模块，实际上是编程的核心思想之一，这样可以把复杂的问题拆解成不同的模块，然后模块之间可以重复使用，在减少开发工作量的同时，还能保证代码的结构清晰。还有一点，存储过程的安全性强，我们在设定存储过程的时候可以设置对用户的使用权限，这样就和视图一样具有较强的安全性。最后它可以减少网络传输量，因为代码封装到存储过程中，每次使用只需要调用存储过程即可，这样就减少了网络传输量。同时在进行相对复杂的数据库操作时，原本需要使用一条一条的SQL语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程，只需要连接一次即可。</p><p>基于上面这些优点，不少大公司都要求大型项目使用存储过程，比如微软、IBM等公司。但是国内的阿里并不推荐开发人员使用存储过程，这是为什么呢？</p><p>存储过程虽然有诸如上面的好处，但缺点也是很明显的。</p><p>它的可移植性差，存储过程不能跨数据库移植，比如在MySQL、Oracle和SQL Server里编写的存储过程，在换成其他数据库时都需要重新编写。</p><p>其次调试困难，只有少数DBMS支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容易。</p><p>此外，存储过程的版本管理也很困难，比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。</p><p>最后它不适合高并发的场景，高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护，增加数据库的压力，显然就不适用了。</p><p>了解了存储过程的优缺点之后，我想说的是，存储过程既方便，又有局限性。尽管不同的公司对存储过程的态度不一，但是对于我们开发人员来说，不论怎样，掌握存储过程都是必备的技能之一。</p><p><img src="https://static001.geekbang.org/resource/image/54/9f/54a0d3b0c0e5336c1da6fc84c909a49f.jpg" alt=""><br><br> 最后我们做一个小练习吧。针对王者荣耀的英雄数据表heros表，请编写存储过程get_sum_score，用来得到某一类型英雄（主要定位为某一类型即可）的最大生命值的总和。</p><p>欢迎你在评论区写下你的答案，也欢迎把这篇文章分享给你的朋友或者同事，一起交流一下。</p>`,53)]))}const t=a(p,[["render",l]]),E=JSON.parse('{"path":"/posts/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9ASQL%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AF%87/13%E4%B8%A8%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%8C%E5%9C%A8%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%BE%97%E5%A4%9A%E4%B9%88%EF%BC%9F.html","title":"13丨什么是存储过程，在实际项目中用得多么？","lang":"zh-CN","frontmatter":{"description":"13丨什么是存储过程，在实际项目中用得多么？ 上一节我介绍了视图，它是SQL中的一个重要应用，使用视图对SQL查询进行封装，可以让SQL的代码结构更清晰，让用户权限管理更安全。 今天我来讲一下SQL的存储过程，它是SQL中另一个重要应用，和视图一样，都是对SQL代码进行封装，可以反复利用。它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/interview/posts/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9ASQL%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AF%87/13%E4%B8%A8%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%8C%E5%9C%A8%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%BE%97%E5%A4%9A%E4%B9%88%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"13丨什么是存储过程，在实际项目中用得多么？"}],["meta",{"property":"og:description","content":"13丨什么是存储过程，在实际项目中用得多么？ 上一节我介绍了视图，它是SQL中的一个重要应用，使用视图对SQL查询进行封装，可以让SQL的代码结构更清晰，让用户权限管理更安全。 今天我来讲一下SQL的存储过程，它是SQL中另一个重要应用，和视图一样，都是对SQL代码进行封装，可以反复利用。它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-16T11:19:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-16T11:19:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"13丨什么是存储过程，在实际项目中用得多么？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-16T11:19:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755343178000,"updatedTime":1755343178000,"contributors":[{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":1,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":11.02,"words":3307},"filePathRelative":"posts/SQL必知必会/第一章：SQL语法基础篇/13丨什么是存储过程，在实际项目中用得多么？.md","localizedDate":"2025年8月16日","excerpt":"\\n<p><audio id=\\"audio\\" title=\\"13丨什么是存储过程，在实际项目中用得多么？\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/7a/cb/7af0629b30613af937de2c126ce081cb.mp3\\"></audio></p>\\n<p>上一节我介绍了视图，它是SQL中的一个重要应用，使用视图对SQL查询进行封装，可以让SQL的代码结构更清晰，让用户权限管理更安全。</p>\\n<p>今天我来讲一下SQL的存储过程，它是SQL中另一个重要应用，和视图一样，都是对SQL代码进行封装，可以反复利用。它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是虚拟表，通常不对底层数据表直接操作，而存储过程是程序化的SQL，可以直接操作底层数据表，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。存储过程可以说是由SQL语句和流控制语句构成的语句集合，它和我们之前学到的函数一样，可以接收输入参数，也可以返回输出参数给调用者，返回计算结果。</p>","autoDesc":true}');export{t as comp,E as data};
