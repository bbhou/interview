import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as e,o as i}from"./app-d8EKP-K0.js";const p={};function r(l,s){return i(),n("div",null,s[0]||(s[0]=[e(`<h1 id="_29丨em聚类-下-用em算法对王者荣耀英雄进行划分" tabindex="-1"><a class="header-anchor" href="#_29丨em聚类-下-用em算法对王者荣耀英雄进行划分"><span>29丨EM聚类（下）：用EM算法对王者荣耀英雄进行划分</span></a></h1><p><audio id="audio" title="29丨EM聚类（下）：用EM算法对王者荣耀英雄进行划分" controls="" preload="none"><source id="mp3" src="https://static001.geekbang.org/resource/audio/68/d6/6879af42f10088cac0d936d2dec92dd6.mp3"></audio></p><p>今天我来带你进行EM的实战。上节课，我讲了EM算法的原理，EM算法相当于一个聚类框架，里面有不同的聚类模型，比如GMM高斯混合模型，或者HMM隐马尔科夫模型。其中你需要理解的是EM的两个步骤，E步和M步：E步相当于通过初始化的参数来估计隐含变量，M步是通过隐含变量来反推优化参数。最后通过EM步骤的迭代得到最终的模型参数。</p><p>今天我们进行EM算法的实战，你需要思考的是：</p><p>如何使用EM算法工具完成聚类？</p><p>什么情况下使用聚类算法？我们用聚类算法的任务目标是什么？</p><p>面对王者荣耀的英雄数据，EM算法能帮助我们分析出什么？</p><h2 id="如何使用em工具包" tabindex="-1"><a class="header-anchor" href="#如何使用em工具包"><span>如何使用EM工具包</span></a></h2><p>在Python中有第三方的EM算法工具包。由于EM算法是一个聚类框架，所以你需要明确你要用的具体算法，比如是采用GMM高斯混合模型，还是HMM隐马尔科夫模型。</p><p>这节课我们主要讲解GMM的使用，在使用前你需要引入工具包：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span>
<span class="line"><span>from sklearn.mixture import GaussianMixture</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们看下如何在sklearn中创建GMM聚类。</p><p>首先我们使用gmm = GaussianMixture(n_components=1, covariance_type=‘full’, max_iter=100)来创建GMM聚类，其中有几个比较主要的参数（GMM类的构造参数比较多，我筛选了一些主要的进行讲解），我分别来讲解下：</p><p>1.n_components：即高斯混合模型的个数，也就是我们要聚类的个数，默认值为1。如果你不指定n_components，最终的聚类结果都会为同一个值。</p><p>2.covariance_type：代表协方差类型。一个高斯混合模型的分布是由均值向量和协方差矩阵决定的，所以协方差的类型也代表了不同的高斯混合模型的特征。协方差类型有4种取值：</p><p>covariance_type=full，代表完全协方差，也就是元素都不为0；</p><p>covariance_type=tied，代表相同的完全协方差；</p><p>covariance_type=diag，代表对角协方差，也就是对角不为0，其余为0；</p><p>covariance_type=spherical，代表球面协方差，非对角为0，对角完全相同，呈现球面的特性。</p><p>3.max_iter：代表最大迭代次数，EM算法是由E步和M步迭代求得最终的模型参数，这里可以指定最大迭代次数，默认值为100。</p><p>创建完GMM聚类器之后，我们就可以传入数据让它进行迭代拟合。</p><p>我们使用fit函数，传入样本特征矩阵，模型会自动生成聚类器，然后使用prediction=gmm.predict(data)来对数据进行聚类，传入你想进行聚类的数据，可以得到聚类结果prediction。</p><p>你能看出来拟合训练和预测可以传入相同的特征矩阵，这是因为聚类是无监督学习，你不需要事先指定聚类的结果，也无法基于先验的结果经验来进行学习。只要在训练过程中传入特征值矩阵，机器就会按照特征值矩阵生成聚类器，然后就可以使用这个聚类器进行聚类了。</p><h2 id="如何用em算法对王者荣耀数据进行聚类" tabindex="-1"><a class="header-anchor" href="#如何用em算法对王者荣耀数据进行聚类"><span>如何用EM算法对王者荣耀数据进行聚类</span></a></h2><p>了解了GMM聚类工具之后，我们看下如何对王者荣耀的英雄数据进行聚类。</p><p>首先我们知道聚类的原理是“人以群分，物以类聚”。通过聚类算法把特征值相近的数据归为一类，不同类之间的差异较大，这样就可以对原始数据进行降维。通过分成几个组（簇），来研究每个组之间的特性。或者我们也可以把组（簇）的数量适当提升，这样就可以找到可以互相替换的英雄，比如你的对手选择了你擅长的英雄之后，你可以选择另一个英雄作为备选。</p><p>我们先看下数据长什么样子：</p><p><img src="https://static001.geekbang.org/resource/image/3c/a0/3c4e14e7b33fc211f96fe0108f6196a0.png" alt=""><br><br> 这里我们收集了69名英雄的20个特征属性，这些属性分别是最大生命、生命成长、初始生命、最大法力、法力成长、初始法力、最高物攻、物攻成长、初始物攻、最大物防、物防成长、初始物防、最大每5秒回血、每5秒回血成长、初始每5秒回血、最大每5秒回蓝、每5秒回蓝成长、初始每5秒回蓝、最大攻速和攻击范围等。</p><p>具体的数据集你可以在GitHub上下载：<a href="https://github.com/cystanford/EM_data" target="_blank" rel="noopener noreferrer">https://github.com/cystanford/EM_data</a>。</p><p>现在我们需要对王者荣耀的英雄数据进行聚类，我们先设定项目的执行流程：</p><img src="https://static001.geekbang.org/resource/image/8a/78/8af94562f6bd3ac42036ec47f5ad2578.jpg" alt=""><p>首先我们需要加载数据源；</p><p>在准备阶段，我们需要对数据进行探索，包括采用数据可视化技术，让我们对英雄属性以及这些属性之间的关系理解更加深刻，然后对数据质量进行评估，是否进行数据清洗，最后进行特征选择方便后续的聚类算法；</p><p>聚类阶段：选择适合的聚类模型，这里我们采用GMM高斯混合模型进行聚类，并输出聚类结果，对结果进行分析。</p><p>按照上面的步骤，我们来编写下代码。完整的代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span># -*- coding: utf-8 -*-</span></span>
<span class="line"><span>import pandas as pd</span></span>
<span class="line"><span>import csv</span></span>
<span class="line"><span>import matplotlib.pyplot as plt</span></span>
<span class="line"><span>import seaborn as sns</span></span>
<span class="line"><span>from sklearn.mixture import GaussianMixture</span></span>
<span class="line"><span>from sklearn.preprocessing import StandardScaler</span></span>
<span class="line"><span> </span></span>
<span class="line"><span># 数据加载，避免中文乱码问题</span></span>
<span class="line"><span>data_ori = pd.read_csv(&#39;./heros7.csv&#39;, encoding = &#39;gb18030&#39;)</span></span>
<span class="line"><span>features = [u&#39;最大生命&#39;,u&#39;生命成长&#39;,u&#39;初始生命&#39;,u&#39;最大法力&#39;, u&#39;法力成长&#39;,u&#39;初始法力&#39;,u&#39;最高物攻&#39;,u&#39;物攻成长&#39;,u&#39;初始物攻&#39;,u&#39;最大物防&#39;,u&#39;物防成长&#39;,u&#39;初始物防&#39;, u&#39;最大每5秒回血&#39;, u&#39;每5秒回血成长&#39;, u&#39;初始每5秒回血&#39;, u&#39;最大每5秒回蓝&#39;, u&#39;每5秒回蓝成长&#39;, u&#39;初始每5秒回蓝&#39;, u&#39;最大攻速&#39;, u&#39;攻击范围&#39;]</span></span>
<span class="line"><span>data = data_ori[features]</span></span>
<span class="line"><span> </span></span>
<span class="line"><span># 对英雄属性之间的关系进行可视化分析</span></span>
<span class="line"><span># 设置plt正确显示中文</span></span>
<span class="line"><span>plt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;] #用来正常显示中文标签</span></span>
<span class="line"><span>plt.rcParams[&#39;axes.unicode_minus&#39;]=False #用来正常显示负号</span></span>
<span class="line"><span># 用热力图呈现features_mean字段之间的相关性</span></span>
<span class="line"><span>corr = data[features].corr()</span></span>
<span class="line"><span>plt.figure(figsize=(14,14))</span></span>
<span class="line"><span># annot=True显示每个方格的数据</span></span>
<span class="line"><span>sns.heatmap(corr, annot=True)</span></span>
<span class="line"><span>plt.show()</span></span>
<span class="line"><span> </span></span>
<span class="line"><span># 相关性大的属性保留一个，因此可以对属性进行降维</span></span>
<span class="line"><span>features_remain = [u&#39;最大生命&#39;, u&#39;初始生命&#39;, u&#39;最大法力&#39;, u&#39;最高物攻&#39;, u&#39;初始物攻&#39;, u&#39;最大物防&#39;, u&#39;初始物防&#39;, u&#39;最大每5秒回血&#39;, u&#39;最大每5秒回蓝&#39;, u&#39;初始每5秒回蓝&#39;, u&#39;最大攻速&#39;, u&#39;攻击范围&#39;]</span></span>
<span class="line"><span>data = data_ori[features_remain]</span></span>
<span class="line"><span>data[u&#39;最大攻速&#39;] = data[u&#39;最大攻速&#39;].apply(lambda x: float(x.strip(&#39;%&#39;))/100)</span></span>
<span class="line"><span>data[u&#39;攻击范围&#39;]=data[u&#39;攻击范围&#39;].map({&#39;远程&#39;:1,&#39;近战&#39;:0})</span></span>
<span class="line"><span># 采用Z-Score规范化数据，保证每个特征维度的数据均值为0，方差为1</span></span>
<span class="line"><span>ss = StandardScaler()</span></span>
<span class="line"><span>data = ss.fit_transform(data)</span></span>
<span class="line"><span># 构造GMM聚类</span></span>
<span class="line"><span>gmm = GaussianMixture(n_components=30, covariance_type=&#39;full&#39;)</span></span>
<span class="line"><span>gmm.fit(data)</span></span>
<span class="line"><span># 训练数据</span></span>
<span class="line"><span>prediction = gmm.predict(data)</span></span>
<span class="line"><span>print(prediction)</span></span>
<span class="line"><span># 将分组结果输出到CSV文件中</span></span>
<span class="line"><span>data_ori.insert(0, &#39;分组&#39;, prediction)</span></span>
<span class="line"><span>data_ori.to_csv(&#39;./hero_out.csv&#39;, index=False, sep=&#39;,&#39;)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果如下：</p><img src="https://static001.geekbang.org/resource/image/db/fb/dbe96b767d7f3ff2dd9f44b651cde8fb.png" alt=""><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[28 14  8  9  5  5 15  8  3 14 18 14  9  7 16 18 13  3  5  4 19 12  4 12</span></span>
<span class="line"><span> 12 12  4 17 24  2  7  2  2 24  2  2 24  6 20 22 22 24 24  2  2 22 14 20</span></span>
<span class="line"><span> 14 24 26 29 27 25 25 28 11  1 23  5 11  0 10 28 21 29 29 29 17]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同时你也能看到输出的聚类结果文件hero_out.csv（它保存在你本地运行的文件夹里，程序会自动输出这个文件，你可以自己看下）。</p><p>我来简单讲解下程序的几个模块。</p><p><strong>关于引用包</strong></p><p>首先我们会用DataFrame数据结构来保存读取的数据，最后的聚类结果会写入到CSV文件中，因此会用到pandas和CSV工具包。另外我们需要对数据进行可视化，采用热力图展现属性之间的相关性，这里会用到matplotlib.pyplot和seaborn工具包。在数据规范化中我们使用到了Z-Score规范化，用到了StandardScaler类，最后我们还会用到sklearn中的GaussianMixture类进行聚类。</p><p><strong>数据可视化的探索</strong></p><p>你能看到我们将20个英雄属性之间的关系用热力图呈现了出来，中间的数字代表两个属性之间的关系系数，最大值为1，代表完全正相关，关系系数越大代表相关性越大。从图中你能看出来“最大生命”“生命成长”和“初始生命”这三个属性的相关性大，我们只需要保留一个属性即可。同理我们也可以对其他相关性大的属性进行筛选，保留一个。你在代码中可以看到，我用features_remain数组保留了特征选择的属性，这样就将原本的20个属性降维到了13个属性。</p><p><strong>关于数据规范化</strong></p><p>我们能看到“最大攻速”这个属性值是百分数，不适合做矩阵运算，因此我们需要将百分数转化为小数。我们也看到“攻击范围”这个字段的取值为远程或者近战，也不适合矩阵运算，我们将取值做个映射，用1代表远程，0代表近战。然后采用Z-Score规范化，对特征矩阵进行规范化。</p><p><strong>在聚类阶段</strong></p><p>我们采用了GMM高斯混合模型，并将结果输出到CSV文件中。</p><p>这里我将输出的结果截取了一段（设置聚类个数为30）：</p><p><img src="https://static001.geekbang.org/resource/image/5c/ce/5c74ffe6741f1bf1bfdf7711932d47ce.png" alt=""><br><br> 第一列代表的是分组（簇），我们能看到张飞、程咬金分到了一组，牛魔、白起是一组，老夫子自己是一组，达摩、典韦是一组。聚类的特点是相同类别之间的属性值相近，不同类别的属性值差异大。因此如果你擅长用典韦这个英雄，不防试试达摩这个英雄。同样你也可以在张飞和程咬金中进行切换。这样就算你的英雄被别人选中了，你依然可以有备选的英雄可以使用。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>今天我带你一起做了EM聚类的实战，具体使用的是GMM高斯混合模型。从整个流程中可以看出，我们需要经过数据加载、数据探索、数据可视化、特征选择、GMM聚类和结果分析等环节。</p><p>聚类和分类不一样，聚类是无监督的学习方式，也就是我们没有实际的结果可以进行比对，所以聚类的结果评估不像分类准确率一样直观，那么有没有聚类结果的评估方式呢？这里我们可以采用Calinski-Harabaz指标，代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>from sklearn.metrics import calinski_harabaz_score</span></span>
<span class="line"><span>print(calinski_harabaz_score(data, prediction))</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>指标分数越高，代表聚类效果越好，也就是相同类中的差异性小，不同类之间的差异性大。当然具体聚类的结果含义，我们需要人工来分析，也就是当这些数据被分成不同的类别之后，具体每个类表代表的含义。</p><p>另外聚类算法也可以作为其他数据挖掘算法的预处理阶段，这样我们就可以将数据进行降维了。</p><p><img src="https://static001.geekbang.org/resource/image/43/d7/43b35b8f49ac83799ea1ca88383609d7.png" alt=""><br><br> 最后依然是两道思考题。针对王者荣耀的英雄数据集，我进行了特征选择，实际上王者荣耀的英雄数量并不多，我们可以省略特征选择这个阶段，你不妨用全部的特征值矩阵进行聚类训练，来看下聚类得到的结果。第二个问题是，依然用王者荣耀英雄数据集，在聚类个数为3以及聚类个数为30的情况下，请你使用GMM高斯混合模型对数据集进行聚类，并得出Calinski_Harabaz分数。</p><p>欢迎在评论区与我分享你的答案，也欢迎点击“请朋友读”，把这篇文章分享给你的朋友或者同事。</p>`,59)]))}const c=a(p,[["render",r]]),o=JSON.parse('{"path":"/posts/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%9845%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E6%A8%A1%E5%9D%97%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E7%AF%87/29%E4%B8%A8EM%E8%81%9A%E7%B1%BB%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E7%94%A8EM%E7%AE%97%E6%B3%95%E5%AF%B9%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%E8%8B%B1%E9%9B%84%E8%BF%9B%E8%A1%8C%E5%88%92%E5%88%86.html","title":"29丨EM聚类（下）：用EM算法对王者荣耀英雄进行划分","lang":"zh-CN","frontmatter":{"description":"29丨EM聚类（下）：用EM算法对王者荣耀英雄进行划分 今天我来带你进行EM的实战。上节课，我讲了EM算法的原理，EM算法相当于一个聚类框架，里面有不同的聚类模型，比如GMM高斯混合模型，或者HMM隐马尔科夫模型。其中你需要理解的是EM的两个步骤，E步和M步：E步相当于通过初始化的参数来估计隐含变量，M步是通过隐含变量来反推优化参数。最后通过EM步骤的...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/interview/posts/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%9845%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E6%A8%A1%E5%9D%97%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E7%AF%87/29%E4%B8%A8EM%E8%81%9A%E7%B1%BB%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E7%94%A8EM%E7%AE%97%E6%B3%95%E5%AF%B9%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%E8%8B%B1%E9%9B%84%E8%BF%9B%E8%A1%8C%E5%88%92%E5%88%86.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"29丨EM聚类（下）：用EM算法对王者荣耀英雄进行划分"}],["meta",{"property":"og:description","content":"29丨EM聚类（下）：用EM算法对王者荣耀英雄进行划分 今天我来带你进行EM的实战。上节课，我讲了EM算法的原理，EM算法相当于一个聚类框架，里面有不同的聚类模型，比如GMM高斯混合模型，或者HMM隐马尔科夫模型。其中你需要理解的是EM的两个步骤，E步和M步：E步相当于通过初始化的参数来估计隐含变量，M步是通过隐含变量来反推优化参数。最后通过EM步骤的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-16T11:19:38.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-16T11:19:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"29丨EM聚类（下）：用EM算法对王者荣耀英雄进行划分\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-16T11:19:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1755343178000,"updatedTime":1755343178000,"contributors":[{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":1,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":10.62,"words":3186},"filePathRelative":"posts/数据分析实战45讲/第二模块：数据分析算法篇/29丨EM聚类（下）：用EM算法对王者荣耀英雄进行划分.md","localizedDate":"2025年8月16日","excerpt":"\\n<p><audio id=\\"audio\\" title=\\"29丨EM聚类（下）：用EM算法对王者荣耀英雄进行划分\\" controls=\\"\\" preload=\\"none\\"><source id=\\"mp3\\" src=\\"https://static001.geekbang.org/resource/audio/68/d6/6879af42f10088cac0d936d2dec92dd6.mp3\\"></audio></p>\\n<p>今天我来带你进行EM的实战。上节课，我讲了EM算法的原理，EM算法相当于一个聚类框架，里面有不同的聚类模型，比如GMM高斯混合模型，或者HMM隐马尔科夫模型。其中你需要理解的是EM的两个步骤，E步和M步：E步相当于通过初始化的参数来估计隐含变量，M步是通过隐含变量来反推优化参数。最后通过EM步骤的迭代得到最终的模型参数。</p>","autoDesc":true}');export{c as comp,o as data};
